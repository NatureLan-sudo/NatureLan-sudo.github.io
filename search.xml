<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>142.环形链表II</title>
    <url>/2022/09/06/142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II%20%20%20%20-%20%20%20%202022-09-06/</url>
    <content><![CDATA[<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<span id="more"></span>
<p><strong>【题目】</strong></p>
<blockquote>
<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/linked-list-cycle-ii" title="https://leetcode.cn/problems/linked-list-cycle-ii">https://leetcode.cn/problems/linked-list-cycle-ii</a></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209062058561.png"></p>
</blockquote>
<blockquote>
<p>分析：</p>
<p>主要考察两知识点：</p>
<ul>
<li><p>判断链表是否环</p>
</li>
<li><p>如果有环，如何找到这个环的入口</p>
</li>
</ul>
</blockquote>
<hr>
<p>【解答】</p>
<p>1、快慢指针 - 常规方法</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<p>分两个步骤进行</p>
<p>①利用快慢指针判断链表是否存在环</p>
<p>这个道理就是一个人一步步跑，另一个人两步两步跑，最后第二个人超越了第一个人一圈，让然后相遇了。如果说不存在环的话，那么快指针会先跑到终点，指向nullptr</p>
<p>②利用双指针判断环的入口-这里涉及到数学推导</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209062058518.png" alt="题目说明"></p>
<p>最终x &#x3D; z ；x是我们想要去求解的量，在fast指针和slow指针相遇后，让fast指针一步步走。让slow从头节点开始一步步走，重合的时候就是结点所在的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast -&gt; next !=<span class="literal">nullptr</span>) &#123; </span><br><span class="line">      <span class="comment">// 保证 fast -&gt; next ;以及 fast -&gt; next -&gt; next 存在</span></span><br><span class="line">      slow = slow -&gt; next;</span><br><span class="line">      fast = fast -&gt; next -&gt; next; <span class="comment">//由于这里向后移动了两次，为了保证不会出现空指针指向空指针</span></span><br><span class="line">      <span class="comment">//判断条件那里需要格外小心</span></span><br><span class="line">      <span class="keyword">if</span> (fast == slow) &#123;  <span class="comment">// 两个节点相遇</span></span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = slow -&gt; next;</span><br><span class="line">        fast = fast -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2、map&#x2F;unordered_map - 常规方法</p>
<p>最基本的想法，创建一个键值表，如果出现了曾经出现过的节点就可以返回了。</p>
<p>时间复杂度：底层基于红黑树的<code>map</code>，在查找某个元素的时候，采用二分查找的办法，时间为<code>O(lgn)</code>；链表n个节点，时间复杂度<code>O(nlgn)</code>. 反之，如果是无序的unordered_map，元素没有排序，所以时间复杂度为<code>O(n)</code></p>
<p>空间复杂度：创建了一个哈希表 O（n）；</p>
<p>利用map 进行实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!head) &#123; <span class="comment">//如果链表是空的直接返回NULL</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     map&lt;ListNode*, <span class="type">int</span>&gt; key;  <span class="comment">// 创建map</span></span><br><span class="line">     ListNode* pcur = head;</span><br><span class="line">     <span class="keyword">while</span> (pcur) &#123; <span class="comment">//当指针不为空的时候就进行</span></span><br><span class="line">     <span class="comment">//先判断是否出现过当前的指针，出现了就直接返回</span></span><br><span class="line">     <span class="keyword">if</span> (key.<span class="built_in">find</span>(pcur) != key.<span class="built_in">end</span>()) &#123; <span class="comment">//发现当前指针对应的并不是map的末尾，说明出现过，那就是环</span></span><br><span class="line">     <span class="keyword">return</span> pcur;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//没出现就添加到map里面</span></span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">       key[pcur] = key[pcur] + <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//指针向前移动</span></span><br><span class="line">     pcur = pcur -&gt; next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 直到遍历完了 末尾空指针跳出了循环说明没有环出现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3、野路子-非常规方法</p>
<p>时间复杂度O(n)</p>
<p>空间复杂度O(1)</p>
<p>链表是在堆上申请的空间，从低向高，如果是按顺序进行链表节点内存的申请，那么我们在环的那一点，一定存在 head → next 小于head；利用这个规律，复杂度为O（n），可以比较快速的解决问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">less</span>&lt;ListNode*&gt;()(head,head-&gt;next)) <span class="comment">// !(head地址小于head -&gt; next)</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">return</span> head -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head -&gt; next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode之链表</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>19.删除链表的倒数第N个元素</title>
    <url>/2022/09/04/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E5%85%83%E7%B4%A0%20%20%20%20-%20%20%20%202022-09-04/</url>
    <content><![CDATA[<p>给你一个链表，删除链表的倒数第N个结点并返回链链表的头结点。利用双指针中的快慢指针解决问题。</p>
<span id="more"></span>
<p><strong>【题目】</strong></p>
<blockquote>
<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209041513536.png"></p>
</blockquote>
<blockquote>
<p><strong>分析：</strong></p>
<p>对于链表而言，访问特定下标的元素是很困难的。</p>
<p>我们做过三个相关的题目：</p>
<p>1、设计链表：在特定的位置插入元素，特定的正向位置删除元素，这需要我们从虚拟头结点开始进行遍历。</p>
<p>2、删除链表的中间节点：这时候我们并不知道应该删除的是哪一个下标，我们通过遍历得到链表的长度也不是现实的，所以我们可以选择利用指针移动之间的倍数关系来实现。即：双指针中的快慢指针，快指针一次走两个格，慢指针一次走一个格，当快指针走到头的时候，慢指针刚好走到了中央的位置。</p>
<p>3、就是我们要删除倒数的元素了，我们可以让快的节点超过慢节点n个元素，当快节点到头的时候，慢节点刚好指向了倒数第n个元素。但需要注意的是，我们希望进行删除操作，所以我们需要在操作第N个元素的前一个节点，所以，判断关系很重要。</p>
</blockquote>
<hr>
<p>【解答】</p>
<p>双指针-快慢双指针法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        prev -&gt; next = head;</span><br><span class="line">        ListNode* slow = prev;</span><br><span class="line">        ListNode* fast = prev;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            fast = fast -&gt; next;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> prev -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast -&gt; next != <span class="literal">nullptr</span>) &#123; <span class="comment">// 要删掉的节点的前一个节点</span></span><br><span class="line">            fast = fast -&gt; next;</span><br><span class="line">            slow = slow -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow -&gt; next = slow -&gt; next -&gt; next;</span><br><span class="line">        <span class="keyword">return</span> prev -&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode之链表</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>160.相交链表</title>
    <url>/2022/09/06/160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%20%20%20%20-%20%20%20%202022-09-06/</url>
    <content><![CDATA[<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。</p>
<span id="more"></span>
<p><strong>【题目】</strong></p>
<blockquote>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209062059291.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209062059102.png"></p>
</blockquote>
<blockquote>
<p>分析：对我而言，这道问题的关键在于相交的定义。相交之后的全部节点都是相同的。因此如果存在相交，两个链表的末端应该是相等的。那么最长的情况就是，长的链表完全包含短的链表。所以我们需要对两个链表进行尾端对齐。</p>
</blockquote>
<hr>
<p>【解答】</p>
<p>1、 尾端对齐</p>
<p>时间复杂度O（m+n）,空间复杂度O（1）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 链表相交代表 相交后的节点都完全一致，最长就是完全覆盖短的链表，短的链表一直到长链表的尾部都重合。</span></span><br><span class="line">        <span class="comment">// 因此，先将链表的尾部对齐，只要是相交，尾部都是对齐的。</span></span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lenB = <span class="number">0</span>;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        <span class="comment">//获得链表A长度</span></span><br><span class="line">        <span class="keyword">while</span> (curA -&gt; next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得链表B长度</span></span><br><span class="line">        <span class="keyword">while</span> (curB -&gt; next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将curA curB置位</span></span><br><span class="line">        curB = headB;</span><br><span class="line">        curA = headA;</span><br><span class="line">        <span class="comment">//将长度更长的置为 A</span></span><br><span class="line">        <span class="keyword">while</span> (lenA &lt; lenB) &#123;</span><br><span class="line">            <span class="built_in">swap</span> (lenA, lenB);</span><br><span class="line">            <span class="built_in">swap</span> (curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n = lenA - lenB;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            curA = curA -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curA == curB) &#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA -&gt; next;</span><br><span class="line">            curB = curB -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode之链表</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 详解构造函数，默认构造，拷贝构造，自定义构造</title>
    <url>/2022/10/09/c++%20%E8%AF%A6%E8%A7%A3%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%20%20%20%20-%20%20%20%202022-09-26/</url>
    <content><![CDATA[<p>如何禁止构造函数的使用，什么是类的默认构造函数？构造函数、析构函数和虚函数，拷贝构造函数，一篇解决</p>
<span id="more"></span>
<h2 id="如何禁止构造函数的使用"><a href="#如何禁止构造函数的使用" class="headerlink" title="如何禁止构造函数的使用"></a>如何禁止构造函数的使用</h2><p>可以为类的构造函数增加<code>delete</code>修饰符，虽然晟敏改了构造函数但是禁止使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var1, var2;</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        var1 = <span class="number">10</span>;</span><br><span class="line">        var2 = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> tmp1, <span class="type">int</span> tmp2) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A ex1;    </span><br><span class="line">    <span class="function">A <span class="title">ex2</span><span class="params">(<span class="number">12</span>,<span class="number">13</span>)</span></span>; <span class="comment">// error: use of deleted function &#x27;A::A(int, int)&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="什么是类的默认构造函数？"><a href="#什么是类的默认构造函数？" class="headerlink" title="什么是类的默认构造函数？"></a>什么是类的默认构造函数？</h2><p>默认构造函数不提供任何实参。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123; <span class="comment">// 类的默认构造函数</span></span><br><span class="line">        var = <span class="number">10</span>;</span><br><span class="line">        c = <span class="string">&#x27;q&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A ex;</span><br><span class="line">    cout &lt;&lt; ex.c &lt;&lt; endl &lt;&lt; ex.var &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">q</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="构造函数、析构函数和虚函数"><a href="#构造函数、析构函数和虚函数" class="headerlink" title="构造函数、析构函数和虚函数"></a>构造函数、析构函数和虚函数</h2><p><strong>构造函数一般不定义为虚函数。</strong> 构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义为虚函数，需要访问对象内存空间中的虚表指针，指向虚函数表找到对应的虚函数。虚函数表是与类绑定的，所以编译的时候就有，但是只有创建了对象才有虚函数指针，但是得通过构造函数创建对象，对象还没有创建，所以也无法进行虚函数的调用。</p>
<p><strong>析构函数一般要定义为虚函数。</strong> 析构函数是要对象进行释放的，如果类之间由继承的关系，用基类指针指向了派生类的对象，但没有定义成虚函数，那么就不能调用对象各自的析构函数，就会造成内存泄漏。</p>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>复制构造函数是构造函数的一种，也称拷贝构造函数，它只有一个参数，参数类型是本类的引用。</p>
<p>如果类的构造者自己不写构造函数的话，编译器也会自动生成一个拷贝构造函数，所以拷贝构造函数是一直存在的。如果自己写构造函数的话，那么就会覆盖掉默认的拷贝构造函数；</p>
<p>拷贝构造函数的一般定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">classname</span> (<span class="type">const</span> classname &amp;obj);</span><br></pre></td></tr></table></figure>

<p><strong>所以说本质就是对于类的对象的引用，通过已有的对象来初始化一个新的对象</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">A</span> (<span class="type">const</span> A &amp;obj);</span><br></pre></td></tr></table></figure>

<p>使用拷贝构造函数初始化一个新的对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">A <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>; <span class="comment">// 使用自己写的构造函数初始化了一个对象c1</span></span><br><span class="line"><span class="function">A <span class="title">c2</span><span class="params">(c1)</span></span>;  <span class="comment">// 使用已经初始化好的对象，通过拷贝构造函数创建了一个新的对象</span></span><br></pre></td></tr></table></figure>

<p>使用自定义的拷贝构造函数初始化一个对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r,<span class="type">double</span> i)&#123;</span><br><span class="line">        real = r; imag = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">const</span> Complex &amp; c)&#123; <span class="comment">// 自己定义的拷贝</span></span><br><span class="line">        real = c.real; imag = c.imag;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Copy Constructor called&quot;</span>&lt;&lt;endl ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">cl</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span> <span class="params">(cl)</span></span>;  <span class="comment">//调用复制构造函数</span></span><br><span class="line">    cout&lt;&lt;c2.real&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;c2.imag;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line">Complex c2 = c1;<span class="comment">//这两条语句是等价的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="禁用拷贝构造函数-x2F-避免拷贝"><a href="#禁用拷贝构造函数-x2F-避免拷贝" class="headerlink" title="禁用拷贝构造函数&#x2F;避免拷贝"></a>禁用拷贝构造函数&#x2F;避免拷贝</h2><p>在c++11之后，出现了<code>delete</code>弃置函数关键帧字，就像之前我们可以直接用delete不用构造函数一样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">noncopyable</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">noncopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">noncopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noncopyable</span>(<span class="type">const</span> noncopyable&amp;) = <span class="keyword">delete</span>; <span class="comment">//拷贝构造函数</span></span><br><span class="line">    noncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> noncopyable&amp;) = <span class="keyword">delete</span>; <span class="comment">// 赋值构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span> : <span class="keyword">private</span> noncopyable &#123; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用<code>operator</code>关键字将c++中原本的运算符进行重载。</p>
<p>使用的基本方式：</p>
<p>如果运算符重载是类的成员函数：(参数列表里写一个参数就行了)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;返回类型&#125; <span class="keyword">operator</span> &#123;运算符&#125; &#123;参数列表&#125;</span><br><span class="line">Box <span class="keyword">operator</span> + (<span class="type">const</span> Box&amp;)</span><br></pre></td></tr></table></figure>

<p>如果运算符重载不是类的成员函数：(参数列表里两个都要写出来)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box <span class="keyword">operator</span> + (<span class="type">const</span> Box&amp;,<span class="type">const</span> Box&amp;)</span><br></pre></td></tr></table></figure>

<p>通过运算符重载，我们可以定义赋值构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">返回类型：noncopyable&amp;</span><br><span class="line">关键字：<span class="keyword">operator</span></span><br><span class="line">运算符：=</span><br><span class="line">参数：<span class="type">const</span> noncopyable&amp;</span><br><span class="line">noncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> noncopyable&amp;) </span><br></pre></td></tr></table></figure>

<h2 id="如何减少构造函数的开销"><a href="#如何减少构造函数的开销" class="headerlink" title="如何减少构造函数的开销"></a>如何减少构造函数的开销</h2><p><strong>在构造函数中使用类初始化列表会较少调用默认的构造函数产生的开销</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">A</span> (): <span class="built_in">ex</span>(<span class="number">1</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不在函数体内对变量赋值，而是在参数列表后，跟一个冒号和初始化列表，效率会更好。</p>
<p>对于类内部非内置类型成员，初始化列表：只调用一次构造；在函数体内赋值：一次默认构造+一次拷贝赋值。非内置类型如string,容器等。</p>
]]></content>
      <categories>
        <category>C++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>三星 C++ 怎么防止内存泄漏</title>
    <url>/2022/09/13/%E4%B8%89%E6%98%9F%20%E6%80%8E%E4%B9%88%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F%20%20%20%20-%20%20%20%202022-09-05/</url>
    <content><![CDATA[<p>内存泄漏将会导致系统内存中无用的空间越来越多，最终导致内存不足，内存爆炸。所以，有必要防止内存泄漏。本文介绍了两种防止内存泄漏的方法以及内存泄漏检测工具valgrind的实现原理。</p>
<span id="more"></span>
<h2 id="1、防止内存泄漏"><a href="#1、防止内存泄漏" class="headerlink" title="1、防止内存泄漏"></a>1、防止内存泄漏</h2><h3 id="1、内部封装"><a href="#1、内部封装" class="headerlink" title="1、内部封装"></a>1、内部封装</h3><p>将内存的分配和释放封装到类中。在类中构造构造函数和析构函数。构造的时候分配内存空间，最后从析构函数中释放内存空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span> p*;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> p_size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">unsigned</span> <span class="type">int</span> n = <span class="number">1</span>) &#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">char</span>[n]; <span class="comment">// 构造函数分配内存</span></span><br><span class="line">    p_size = n;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">A</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="keyword">delete</span>[] p; <span class="comment">// 删除字符数组的内存空间，在堆上</span></span><br><span class="line">     p = <span class="literal">NULL</span>;  <span class="comment">// p指向的空间已经被删除了，给p重新赋值，避免出现野指针。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该方法不是最佳的做法，因为在类的对象复制时，程序会出现同一块内存空间释放两次的情况。</p>
<p>在一个函数内创建两个类的对象，让一个对象等于另一个对象。在离开函数作用域的时候，将会调用两次析构函数来释放空间，但是两个对象指向同一块内存，所以同一块内存就被释放了两次。** 可以通过增加计数机制来避免这种情况**；</p>
<h3 id="2、智能指针"><a href="#2、智能指针" class="headerlink" title="2、智能指针"></a>2、智能指针</h3><p>智能指针是 C++ 中已经对内存泄漏封装好了一个工具，可以直接拿来使用。可以自己计数。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209132043830.png"></p>
<p><img data-src="/image/image_VK2HHXZfof.png"></p>
]]></content>
      <categories>
        <category>c++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 详解虚函数和纯虚函数</title>
    <url>/2022/10/09/c++%E8%AF%A6%E8%A7%A3%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%20%20%20%20-%20%20%20%202022-09-24/</url>
    <content><![CDATA[<p>多态性是面向对象三大特性之一。封装、继承和多态——三大特性。</p>
<p>多态性分为编译时的多态性和运行时候的多态性。</p>
<p>多态性指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。</p>
<p>编译时： 重载函数、运算符重载</p>
<p>运行时：虚函数和继承实现</p>
<span id="more"></span>

<p>纯虚函数是在定义的时候在末尾加上<code> =0</code>；</p>
<p>纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做<a href="https://baike.baidu.com/item/%E6%8A%BD%E8%B1%A1%E7%B1%BB?fromModule=lemma_inlink" title="抽象类">抽象类</a>。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。</p>
<p>定义一个函数为纯虚函数，代表函数没有被实现，等待派生类对其进行实现。</p>
<p>定义一个函数为虚函数，不代表没有被实现，只是为了允许基类的指针指向派生类对象的时候，可以调用对应的派生类函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funtion1</span><span class="params">()</span></span>=<span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>带有纯虚函数的类叫做抽象类。纯虚函数最显著的特征是，他们必学在 继承类中重新声明函数。</p>
<p>抽象类只能作为基类使用，抽象类不能定义实例，但是可以声明指向该抽象类的具体类的指针或者引用。</p>
<p>友元函数不是成员函数，可以访问私有成员，但是只有成员函数才是可以虚拟的，所以友元函数不能是虚拟函数。</p>
<h3 id="虚函数和纯虚函数的区别"><a href="#虚函数和纯虚函数的区别" class="headerlink" title="虚函数和纯虚函数的区别"></a>虚函数和纯虚函数的区别</h3><p>1、虚函数和纯虚函数可以出现在同一个类中，该类称为抽象类基类</p>
<p>2、使用方式不同，虚函数可以直接使用，但是纯虚函数必须在派生类中实现后才能使用</p>
<p>3、定义形式不同，纯虚函数需要virtual关键字+ &#x3D;0，虚函数只加virtual关键字就可以了</p>
<p>4、虚函数必须实现，否则编译器会报错</p>
<p>5、虚函数和纯虚函数都可以在派生类中重写</p>
<p>6、基类的析构函数最好定义为虚函数，否则派生类对象可能会造成内存泄漏，考虑如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> baseData;</span><br><span class="line">  ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> derivedData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">  <span class="keyword">delete</span> b;  <span class="comment">// 由于 Base 的析构函数不是虚函数，</span></span><br><span class="line">        <span class="comment">// 这里调用的是 Base 的析构函数，</span></span><br><span class="line">        <span class="comment">// 而非 Derived 的析构函数,</span></span><br><span class="line">        <span class="comment">// 因此，Derived 里的 derivedData 没有被释放，</span></span><br><span class="line">        <span class="comment">// 因此，内存泄漏。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果一个类被其他类继承，那么析构函数最好声明为虚函数。</p>
<h3 id="虚函数的实现机制"><a href="#虚函数的实现机制" class="headerlink" title="虚函数的实现机制"></a>虚函数的实现机制</h3><p>虚函数是通过虚函数表实现的，虚函数表中，包含了虚函数的地址。<strong>虚函数表是和类绑定的</strong>，也就是类的所有对象用的都是同一张虚函数表。在类的对象所存在的内存空间中，保存了指向虚函数表的指针，被称虚表指针，通过虚表指针可以找到类的虚函数表。<strong>所以虚表指针是和对象绑定的，每个对象的虚表指针不一样，但是指向的是同一张表。</strong></p>
<p>无虚函数覆盖情况下的虚函数表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">B_fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::B_fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">B_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::B_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">B_fun3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::B_fun3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">D_fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">D_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">D_fun3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">    p-&gt;<span class="built_in">B_fun1</span>(); <span class="comment">// Base::B_fun1()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>基类和派生类的继承关系</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202210091501938.png"></p>
<p>基类的虚函数表：</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202210091501050.png"></p>
<p>派生类的虚函数表：</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202210091501889.png"></p>
<p>子类没有重写虚函数的时候，子类对象的虚表指针指向基类的虚函数表，子类没有虚函数表。但是当子类重写基类虚函数或者添加了一个新的虚函数的时候，子类会有一个自己的虚函数表，表中会存放基类虚函数的地址</p>
<h3 id="单继承和多继承的虚函数表结构"><a href="#单继承和多继承的虚函数表结构" class="headerlink" title="单继承和多继承的虚函数表结构"></a>单继承和多继承的虚函数表结构</h3><p>两个父类的多继承（其他以此类推）总结：</p>
<p>两个虚函数指针分别指两个虚函数表。每个虚函数表保存每个父类的虚函数地址。<strong>即，继承多个基类的时候，子类有多个虚表指针。</strong><br>内存布局与继承的父类的顺序有关，<strong>子类的虚函数插入到第一个虚指针所指的虚函数表中。</strong><br>特别关注子类的虚析构函数。第二个虚指针调用虚析构函数时，会跳转到第一个虚函数表调用子类虚析构函数。<br>子类的虚函数表中虚函数的顺序与父类一样，若子类重写父类虚函数，即在<strong>虚函数表中原位置覆盖</strong>即可。</p>
]]></content>
      <categories>
        <category>C++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ 内联函数详解-用空间换速度</title>
    <url>/2022/09/20/inline%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%20%20%20%20-%20%20%20%202022-09-19/</url>
    <content><![CDATA[<p>inline是一个关键字，可以用于定义内联函数。内联函数可以像普通函数一样被调用，但是是在调用点直接展开而不是通过函数调用机制调用。可以大大减少由函数调用带来的开销，从而提高程序的运行效率。</p>
<p>如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。</p>
<p>对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。</p>
<p><strong>因此，事实就是我们利用空间代价换取了时间上的效率。因此，内联函数应该是比较短小的函数，一般只有几行。</strong></p>
<span id="more"></span>
<h2 id="类和内联函数"><a href="#类和内联函数" class="headerlink" title="类和内联函数"></a>类和内联函数</h2><p>类内定义成员函数默认是内联函数<br><strong>在类内定义成员函数</strong>，可以不用在函数头部加 inline 关键字，因为编译器会自动将类内定义的函数（构造函数、析构函数、普通成员函数等）声明为内联函数，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> tmp)&#123; </span><br><span class="line">      var = tmp;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;   <span class="comment">//在类内定义的函数，是内联函数</span></span><br><span class="line">        cout &lt;&lt; var &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类外定义成员函数，若想定义为内联函数，需用关键字声明<br>当在类内声明函数，在类外定义函数时，如果想将该函数定义为内联函数，则可以在类内<strong>声明时不加</strong> <code>inline</code> 关键字，而在<strong>类外定义函数时加上</strong><code> inline </code>关键字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> tmp)&#123; </span><br><span class="line">      var = tmp;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">A::fun</span><span class="params">()</span></span>&#123;　<span class="comment">//　类外定义了内联函数</span></span><br><span class="line">    cout &lt;&lt; var &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外，可以在声明函数和定义函数的同时加上 inline；也可以只在函数声明时加 inline，而定义函数时不加 inline。只要确保在调用该函数之前把 inline 的信息告知编译器即可。</p>
<h2 id="内联函数的工作原理"><a href="#内联函数的工作原理" class="headerlink" title="内联函数的工作原理"></a>内联函数的工作原理</h2><p>内联函数不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。<br>普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销。</p>
<h2 id="宏定义define和内联函数inline的区别"><a href="#宏定义define和内联函数inline的区别" class="headerlink" title="宏定义define和内联函数inline的区别"></a>宏定义define和内联函数inline的区别</h2><p>1、内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。<br>2、内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义编写较为复杂，常需要增加一些括号来避免歧义。</p>
<p>3、宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">fun_max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> var = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">MAX</span>(var, <span class="number">5</span>) &lt;&lt; endl;     </span><br><span class="line">    cout &lt;&lt; <span class="built_in">fun_max</span>(var, <span class="number">0</span>) &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">程序运行结果：</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ 函数重载、隐藏、重写（覆盖、虚函数）</title>
    <url>/2022/09/20/%E4%BA%94%E6%98%9F%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E3%80%81%E9%9A%90%E8%97%8F%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0-%20%20%20%202022-09-13/</url>
    <content><![CDATA[<p>函数重载在相同的作用域，同样的函数名，不同的形参（不同顺序、类型、个数）<br>函数隐藏在不同作用域（基类和派生类），同样的函数名，相同或不同的参数，需要实例化相应的对象才能调用相应的成员函数。<br>重写、覆盖需要用虚函数，是多态的思想，在不同的作用域，同样的函数名，参数值列表相同，返回值类型相同，只有函数体不同。需要区别隐藏和重写。</p>
<span id="more"></span>
<h2 id="1、函数重载"><a href="#1、函数重载" class="headerlink" title="1、函数重载"></a>1、函数重载</h2><p><strong>在相同的作用域，同样的函数名，不同的形参（不同顺序、类型、个数）。</strong></p>
<p>根据参数列表确定调用哪个函数，重载不关心返回类型</p>
<h2 id="2、函数隐藏（重定义）"><a href="#2、函数隐藏（重定义）" class="headerlink" title="2、函数隐藏（重定义）"></a>2、函数隐藏（重定义）</h2><p><strong>在不同的作用域（基类和派生类），同样的函数名，</strong> ​<strong>相同或者不同的参数。</strong></p>
<p>实例化基类对象，可以调用基类的函数</p>
<p>实例化派生类对象，可以调用派生类的函数</p>
<p>派生类可以重写与基类函数名相同的函数，可以修改输入的形参，上述操作叫做函数隐藏</p>
<h2 id="3、重写、覆盖（虚函数）"><a href="#3、重写、覆盖（虚函数）" class="headerlink" title="3、重写、覆盖（虚函数）"></a>3、重写、覆盖（虚函数）</h2><p>**在不同的作用域（基类和派生类），同样的函数名，<strong><strong>参数列表相同、返回值类型相同，只有函数体不同</strong></strong>，**使用关键字<code>virtual</code>（一般就是直接写在基类函数名前，这样派生类的函数就都是虚函数了）。</p>
<p>在进行隐藏后，基类对象可以调用基类函数，派生类对象可以调用派生类函数。但是用基类的指针指向派生类对象，再调用函数时，就只会调用基类的函数，而不会调用派生类对象的派生函数。</p>
<p>但是如果我们加上virtual关键字，指向派生类对象的基类指针就可以调用其指向的派生类对象的函数。</p>
<p>将派生类对象赋值给基类的指针或者引用来调用派生类的方法有很多好处，例如可以利用基类对象动态确定其所指向的派生类对象的函数方法，就会避免我们写很多函数，一一调用。</p>
<p>当我们加上virtual，基类指针或者引用就可以动态确定派生类对象的方法，并调用，而不是调用基类的方法了。</p>
<p>**隐藏和重写的一个区别：<br>**在使用效果上，重写可以用于实现多态，隐藏不可以，即使都使用了虚函数。如果使用基类指针p指向派生类对象，利用这个指针调用函数时，对于隐藏的函数，会根据指针的类型去调用函数；对于重写的函数，会根据指针所指对象的类型去调用函数。可能是因为只有重写才会更改派生类虚函数表的表项。</p>
<p>补充：</p>
<p>override关键字的作用</p>
<p>如果派生类在虚函数声明时候使用了override，那么该函数必须重写其基类中的同名函数，否则无法通过编译。</p>
<p>可以利用这一性质检查虚函数是否真正重写正确了，否则编译可以通过，但是没有实现真正的重写。override是让编译器检查你是否重写虚函数啦，没有的话 编译阶段提示一下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Turing</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VNeumann</span><span class="params">(<span class="type">int</span> g)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DKnuth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DerivedMid</span>: <span class="keyword">public</span> Base </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// void VNeumann(double g);</span></span><br><span class="line">    <span class="comment">//接口被隔离了，曾想多一个版本的VNeumann函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DerivedTop</span> : <span class="keyword">public</span> DerivedMid </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Turing</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Dikjstra</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//无法通过编译，拼写错误，并非重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">VNeumann</span><span class="params">(<span class="type">double</span> g)</span> <span class="keyword">override</span></span>; <span class="comment">//无法通过编译，参数不一致，并非重载    </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DKnuth</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//无法通过编译，常量性不一致，并非重载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//无法通过编译，非虚函数重载</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>const修饰的常成员函数也可以重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> tmp, <span class="type">float</span> tmp1)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun(int tmp, float tmp1)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> tmp, <span class="type">float</span> tmp1)</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const Class !!!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    b.<span class="built_in">fun</span>(<span class="number">1</span>,<span class="number">2.0</span>);       <span class="comment">//Base::fun(int tmp, float tmp1)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> Base cb;</span><br><span class="line">    cb.<span class="built_in">fun</span>(<span class="number">1</span>,<span class="number">2.5</span>);      <span class="comment">//const Class !!!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>原因是const修饰可以理解为， 这里有一个常量指针，即this指向的地址里的内容不可以改变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span> <span class="params">(<span class="type">const</span> Base *<span class="keyword">this</span>, <span class="type">int</span> tmp, <span class="type">float</span> tmp1)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>无const修饰可以理解为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span> <span class="params">(Base *<span class="keyword">this</span>, <span class="type">int</span> tmp, <span class="type">float</span> tmp1)</span></span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>五星 C++ 堆和栈的区别</title>
    <url>/2022/09/02/%E4%BA%94%E6%98%9F%20C++%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E5%8C%BA%E5%88%AB%20%20%20-%20%20%20%202022-08-29/</url>
    <content><![CDATA[<p><strong>申请方式：</strong> 栈是系统自动分配，堆是程序员主动申请。<strong>申请后系统响应：</strong>分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。<br>栈在内存中是连续的一块空间（向低地址扩展）<strong>最大容量是系统预定好的</strong>，堆在内存中的空间（向高地址扩展）是<strong>不连续</strong>的。<br><strong>申请效率：</strong> 栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。<br><strong>存放的内容：</strong> 栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。</p>
<span id="more"></span>

<p><strong>问题1：堆的内存为什么是不连续的</strong></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209021418598.png"></p>
<p><strong>问题2：堆和栈的不同点</strong></p>
<p>管理方式：堆-程序员。栈-系统。</p>
<p>空间大小：堆-不确定。栈-最大容量是系统设定好的。</p>
<p>生长方向：堆-向高地址扩展，不连续。栈-向低地址扩展，连续。</p>
<p>分配效率：堆-程序员申请，效率低，容易产生碎片。栈-系统分配，效率高，但是程序员不能控制。</p>
<p>存放内容：堆-程序员自己申请的内容。栈-局部变量，函数参数等。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209021418580.png"></p>
]]></content>
      <categories>
        <category>C++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>五星 C++ 智能指针的分类、实现原理、易出现的问题</title>
    <url>/2022/09/13/%E4%BA%94%E6%98%9F%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%88%86%E7%B1%BB%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E3%80%81%E6%98%93%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%20%20%20-%20%20%20%202022-09-05/</url>
    <content><![CDATA[<p>智能指针是高频考察内容；本文讲述了智能指针的分类，实现原理以及容易出现的问题及其解决方式。</p>
<p>智能指针是为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的。C++11 中封装在了 <code>&lt;memory&gt;</code> 头文件中。</p>
<span id="more"></span>

<p>C++11 中智能指针包括以下三种：</p>
<ul>
<li><p><strong>共享指针（shared_ptr）</strong>：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过 <code>use_count()</code> 查看资源的所有者的个数，可以通过 <code>unique_ptr</code>、<code>weak_ptr</code> 来构造，调用 <code>release()</code> 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。</p>
</li>
<li><p><strong>独占指针（unique_ptr）</strong>：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用 <code>move()</code> 函数），即一个 <code>unique_ptr</code> 对象赋值给另一个 <code>unique_ptr</code> 对象，可以通过该方法进行赋值。</p>
</li>
<li><p><strong>弱指针（weak_ptr）</strong>：指向 <code>share_ptr</code> 指向的对象，能够解决由shared_ptr带来的循环引用问题。</p>
</li>
</ul>
<p>智能指针的实现原理是计数原理。</p>
<blockquote>
<p>在C++中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针（smart pointer）。智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。</p>
</blockquote>
<h2 id="1、共享指针（shared-ptr）"><a href="#1、共享指针（shared-ptr）" class="headerlink" title="1、共享指针（shared_ptr）"></a>1、共享指针（shared_ptr）</h2><h3 id="1、初始化"><a href="#1、初始化" class="headerlink" title="1、初始化"></a>1、初始化</h3><blockquote>
<p>共享智能指针是指多个智能指针可以同时管理同一块有效的内存，共享智能指针shared_ptr 是一个模板类，如果要进行初始化有三种方式：通过构造函数、std::make_shared辅助函数以及reset方法。共享智能指针对象初始化完毕之后就指向了要管理的那块堆内存，如果想要查看当前有多少个智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数use_count。<strong>如果我们不初始化一个智能指针，他会被初始化为一个空指针 。</strong></p>
</blockquote>
<h3 id="2、获得原始地址"><a href="#2、获得原始地址" class="headerlink" title="2、获得原始地址"></a>2、获得原始地址</h3><blockquote>
<p>利用get()获得原地址；对应基础数据类型来说，通过操作智能指针和操作智能指针管理的内存效果是一样的，可以直接完成数据的读写。但是如果共享智能指针管理的是一个对象，那么就需要取出原始内存的地址再操作，可以调用共享智能指针类提供的get()方法得到原始地址</p>
</blockquote>
<h3 id="3、指定删除器"><a href="#3、指定删除器" class="headerlink" title="3、指定删除器"></a>3、指定删除器</h3><blockquote>
<p>当智能指针管理的内存对应的引用计数变为0的时候，这块内存就会被智能指针析构掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为删除器，这个删除器函数本质是一个回调函数，我们只需要进行实现，其调用是由智能指针完成的。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">m_num</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> x) : <span class="built_in">m_num</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test, x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Test</span>(string str) : <span class="built_in">m_num</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destruct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_num = v;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m_num: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*--------------------------  一，初始化智能指针shared_ptr  ------------------------------*/</span></span><br><span class="line">    <span class="comment">//1.通过构造函数初始化</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">3</span>))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//2.通过移动和拷贝构造函数初始化</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3 = ptr2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//3.通过 std::make_shared初始化 这种初始化方法是最好的</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr4 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">8</span>);</span><br><span class="line">    shared_ptr&lt;Test&gt; ptr5 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="number">7</span>);</span><br><span class="line">    shared_ptr&lt;Test&gt; ptr6 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="string">&quot;GOOD LUCKLY!&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//4.通过reset初始化</span></span><br><span class="line">    ptr6.<span class="built_in">reset</span>(); <span class="comment">//重置ptr6, ptr6的引用基数为0</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr6管理的内存引用计数: &quot;</span> &lt;&lt; ptr6.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    ptr5.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr5管理的内存引用计数: &quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*--------------------------  二，共享智能指针shared_ptr的使用  ------------------------------*/</span></span><br><span class="line">    <span class="comment">//1.方法一</span></span><br><span class="line">    Test* t = ptr5.<span class="built_in">get</span>();</span><br><span class="line">    t-&gt;<span class="built_in">setValue</span>(<span class="number">1000</span>);</span><br><span class="line">    t-&gt;<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//2.方法二</span></span><br><span class="line">    ptr5-&gt;<span class="built_in">setValue</span>(<span class="number">7777</span>);</span><br><span class="line">    ptr5-&gt;<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">    <span class="comment">/*------------------------------------  三，指定删除器  -----------------------------------*/</span></span><br><span class="line">     <span class="comment">//1.简单举例</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">ppp</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">100</span>), [](Test* t) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">//释放内存</span></span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;Test对象的内存被释放了.......&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">delete</span> t;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="number">2.</span>如果是数组类型的地址，就需要自己写指定删除器，否则内存无法全部释放</span><br><span class="line">    <span class="comment">//shared_ptr&lt;Test&gt; p1(new Test[5], [](Test* t) &#123;</span></span><br><span class="line">    <span class="comment">//    delete[]t;</span></span><br><span class="line">    <span class="comment">//    &#125;);</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//3.也可以使用c++给我们提供的 默认删除器函数（函数模板）</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">3</span>], default_delete&lt;Test[]&gt;())</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//4.c++11以后可以这样写 也可以自动释放内存</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Test[]&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">3</span>])</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外，我们还可以自己封装一个函数模板make_shared_array方法来让shared_ptr支持数组，代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//有了这个函数模板，我们就不用自己去释放数组类型的地址了</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">make_share_array</span><span class="params">(<span class="type">size_t</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//返回匿名对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T[size], <span class="built_in">default_delete</span>&lt;T[]&gt;());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_share_array</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">  cout &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">  shared_ptr&lt;string&gt; ptr2 = <span class="built_in">make_share_array</span>&lt;string&gt;(<span class="number">7</span>);</span><br><span class="line">  cout &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最安全的分配和使用动态内存的方法是调用make_shared标准库函数。此函数在动态内存中分配一个对象并从初始化它，返回指向此对象的shared_ptr。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt; (<span class="number">42</span>);</span><br><span class="line"><span class="comment">//要指定类型和初始化的内容，指向一个值为42的int类型的智能指针。</span></span><br></pre></td></tr></table></figure>

<p>我们不能将一个内置指针转换为一个智能指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>);<span class="comment">//这种是错误的</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">100</span>))</span></span>; <span class="comment">//这种是正确的</span></span><br></pre></td></tr></table></figure>

<h2 id="2、独占指针-unique-ptr"><a href="#2、独占指针-unique-ptr" class="headerlink" title="2、独占指针 (unique_ptr)"></a>2、独占指针 (unique_ptr)</h2><h3 id="1、初始化-1"><a href="#1、初始化-1" class="headerlink" title="1、初始化"></a>1、初始化</h3><blockquote>
<p>std::unique_ptr是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针，可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个unique_ptr赋值给另一个unique_ptr。不过我们可以通过move函数，将一个独占指针的值赋给另一个独占指针。</p>
</blockquote>
<p>独占指针的初始化必须采用直接初始化方式，不支持拷贝，也不支持赋值。</p>
<p>正确的初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; ptr;</span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">55</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p>错误的初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(ptr1)</span></span>; <span class="comment">//错误，不支持拷贝</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; ptr = ptr1; <span class="comment">// 错误，不支持赋值。</span></span><br></pre></td></tr></table></figure>

<h3 id="2、删除器"><a href="#2、删除器" class="headerlink" title="2、删除器"></a>2、删除器</h3><p>问题：如何将一个unique_ptr赋值给另一个unique_ptr?</p>
<p>A：可以利用std::move，其目的是实现所有权的转移。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A 作为一个类 </span></span><br><span class="line"><span class="function">std::unique_ptr&lt;A&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">std::unique_ptr&lt;A&gt; ptr2 = std::<span class="built_in">move</span>(ptr1);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">m_num</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> x) : <span class="built_in">m_num</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test, x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Test</span>(string str) : <span class="built_in">m_num</span>(<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destruct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_num = v;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m_num: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*--------------------------  一，初始化智能指针unique_ptr  ------------------------------*/</span></span><br><span class="line">    <span class="comment">//1.通过构造函数初始化</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">3</span>))</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//2.通过移动函数初始化</span></span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//.通过reset初始化</span></span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">7</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*--------------------------  二，unique_ptr的使用  ------------------------------*/</span></span><br><span class="line">    <span class="comment">//1.方法一</span></span><br><span class="line">    <span class="function">unique_ptr&lt;Test&gt; <span class="title">ptr3</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">666</span>))</span></span>;</span><br><span class="line">    Test* pt = ptr3.<span class="built_in">get</span>();</span><br><span class="line">    pt-&gt;<span class="built_in">setValue</span>(<span class="number">6</span>);</span><br><span class="line">    pt-&gt;<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//2.方法二</span></span><br><span class="line">    ptr3-&gt;<span class="built_in">setValue</span>(<span class="number">777</span>);</span><br><span class="line">    ptr3-&gt;<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*------------------------------------  三，指定删除器  -----------------------------------*/</span></span><br><span class="line">    <span class="comment">//1.函数指针类型</span></span><br><span class="line">    <span class="comment">//using ptrFunc = void(*)(Test*);</span></span><br><span class="line">    <span class="comment">//unique_ptr&lt;Test, ptrFunc&gt; ptr4(new Test(&quot;hello&quot;), [](Test* t) &#123;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//    delete t;</span></span><br><span class="line">    <span class="comment">//    &#125;);</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//2.仿函数类型（利用可调用对象包装器）</span></span><br><span class="line">    unique_ptr&lt;Test, function&lt;<span class="type">void</span>(Test*)&gt;&gt; <span class="built_in">ptr4</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="string">&quot;hello&quot;</span>), [](Test* t) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> t;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*---------- 四，独占(共享)的智能指针可以管理数组类型的地址，能够自动释放 ---------*/</span></span><br><span class="line">    <span class="function">unique_ptr&lt;Test[]&gt; <span class="title">ptr5</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">3</span>])</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在c++11中shared_ptr不支持下面的写法，c++11以后才支持的</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Test[]&gt; <span class="title">ptr6</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">3</span>])</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、弱指针-weak-ptr"><a href="#3、弱指针-weak-ptr" class="headerlink" title="3、弱指针 (weak_ptr)"></a>3、弱指针 (weak_ptr)</h2><p>弱引用智能指针std::weak_ptr可以看做是shared_ptr的助手，它不管理shared_ptr内部的指针。std::weak_ptr没有重载操作符*和-&gt;，因为它不共享指针，不能操作资源，所以它的构造不会增加引用计数，析构也不会减少引用计数，它的主要作用就是作为一个旁观者监视shared_ptr中管理的资源是否存在。</p>
<h3 id="1、初始化-2"><a href="#1、初始化-2" class="headerlink" title="1、初始化"></a>1、初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp1;</span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp2</span><span class="params">(wp1)</span></span>;</span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp3</span><span class="params">(sp)</span></span>;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp4;</span><br><span class="line">    wp4 = sp;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp5;</span><br><span class="line">    wp5 = wp3;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>weak_ptr&lt;int&gt; wp1;构造了一个空weak_ptr对象</p>
<p>weak_ptr&lt;int&gt; wp2(wp1);通过一个空weak_ptr对象构造了另一个空weak_ptr对象</p>
<p>weak_ptr&lt;int&gt; wp3(sp);通过一个shared_ptr对象构造了一个可用的weak_ptr实例对象</p>
<p>wp4 &#x3D; sp;通过一个shared_ptr对象构造了一个可用的weak_ptr实例对象（这是一个隐式类型转换）</p>
<p>wp5 &#x3D; wp3;通过一个weak_ptr对象构造了一个可用的weak_ptr实例对象</p>
<p>通过调用std::weak_ptr类提供的use_count()方法可以获得当前所观测资源的引用计数</p>
<h3 id="2、常用函数"><a href="#2、常用函数" class="headerlink" title="2、常用函数"></a>2、常用函数</h3><p>通过调用std::weak_ptr类提供的expired()方法来判断观测的资源是否已经被释放</p>
<p>通过调用std::weak_ptr类提供的lock()方法来获取管理所监测资源的shared_ptr对象</p>
<p>通过调用std::weak_ptr类提供的reset()方法来清空对象，使其不监测任何资源</p>
<ul>
<li>利用**<code>weak_ptr可以解决shared_ptr的一些问题</code>**</li>
</ul>
<ol>
<li>返回管理this的shared_ptr</li>
</ol>
<p>&amp;#x20;2.  解决循环引用问题</p>
<h2 id="4、使用是智能指针会出现什么问题？"><a href="#4、使用是智能指针会出现什么问题？" class="headerlink" title="4、使用是智能指针会出现什么问题？"></a>4、使用是智能指针会出现什么问题？</h2><p>循环引用；</p>
<p>两个类内的循环指针互相指向，没有指向环中的外部共享指针，<code>shared_ptr</code> 引用计数无法抵达 0，该调用析构函数但是没能调用，导致了内存泄漏。</p>
<p>使用弱指针，可以避免这个问题：</p>
<ul>
<li><p><code>weak_ptr</code>对被<code>shared_ptr</code>管理的对象存在<strong>非拥有性引用</strong>，在访问所引用的对象前必须先转化为<code>shared_ptr</code>；</p>
</li>
<li><p><code>weak_ptr</code>用来打断<code>shared_ptr</code>所管理对象的循环引用问题，若这种环被孤立（没有指向环中的外部共享指针），<code>shared_ptr</code>引用计数无法抵达0，内存被泄露；令环中的指针之一为弱指针可以避免该情况。</p>
</li>
<li><p><code>weak_ptr</code>用来表示临时所有权的概念。当某个对象只有存在时才需要被访问，而且随时可能被他人删除，可以用<code>weak_ptr</code>跟踪该对象；需要获得所有权时将其转化为<code>shared_ptr</code>，此时如果原来的<code>shared_ptr</code>被销毁，则该对象的生命周期被延长到这个临时的<code>shared_ptr</code>同样被销毁。</p>
</li>
</ul>
<p>未使用弱指针：</p>
<p>起初定义完<code>ptr_a</code>和<code>ptr_b</code>时，只有1，3两条引用，即<code>ptr_a</code>指向CA对象，<code>ptr_b</code>指向CB对象。然后调用函数<code>set_ptr()</code>后又增加了2，4两条引用，即CB对象中的<code>m_ptr_a</code>成员变量指向CA对象，CA对象中的<code>m_ptr_b</code>成员变量指向CB对象。</p>
<p>这个时候，指向CA对象的有两个，指向CB对象的也有两个。当main函数运行结束时，对象<code>ptr_a</code>和<code>ptr_b</code>被销毁，也就是1，3两条引用会被断开，2，4两条引用依然存在，每一个的引用计数都不为0，结果就导致其指向的内部对象无法析构，造成内存泄漏。</p>
<p>2，4之间的引用，m_ptr_a指向CA，CA不为空，m_ptr_a有效，不能被释放掉。同时由于m_ptr_a的存在，CB不为空，m_ptr_b不能被释放掉。这就导致了这两个相互引用的次数一直为1，不能被释放，计数机制失效了，造成了内存泄漏。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209132044091.png"></p>
<p>使用弱指针：</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209132044244.png"></p>
<p>流程与上一例子大体相似，但是不同的是4这条引用是通过<code>weak_ptr</code>建立的，并不会增加引用计数。也就是说，CA的对象只有一个引用计数，而CB的对象只有两个引用计数，当main函数返回时，对象<code>ptr_a</code>和<code>ptr_b</code>被销毁，也就是1，3两条引用会被断开，此时CA对象的引用计数会减为0，对象被销毁，进而解决了引用成环的问题。</p>
<h2 id="5、使用new和delete管理动态内存的缺点（坚持使用智能指针）"><a href="#5、使用new和delete管理动态内存的缺点（坚持使用智能指针）" class="headerlink" title="5、使用new和delete管理动态内存的缺点（坚持使用智能指针）"></a>5、使用new和delete管理动态内存的缺点（坚持使用智能指针）</h2><p>使用new和delete管理动态内存容易存在问题：</p>
<p>1、忘记用delete 释放内存</p>
<p>2、同一块内存由于拷贝，可能被释放了两次</p>
<p>3、可能会使用释放后的对象</p>
<p>因此，坚持使用智能指针，可以避免所有这些问题，对于一块内存，只有在没有任何指针指向的时候，才会释放他。</p>
]]></content>
      <categories>
        <category>c++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ 动态内存管理 new，与malloc区分介绍</title>
    <url>/2022/09/20/%E5%8A%A8%E6%80%81%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%20new%20%20%20-%20%20%20%202022-09-19/</url>
    <content><![CDATA[<p>new关键字，c++中用于动态管理内存，实现在自由存储区建立对象，由程序员自己进行内存管理。</p>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]; </span><br></pre></td></tr></table></figure>

<h3 id="new-和-malloc-的区别，delete-和-free-的区别"><a href="#new-和-malloc-的区别，delete-和-free-的区别" class="headerlink" title="new 和 malloc 的区别，delete 和 free 的区别"></a>new 和 malloc 的区别，delete 和 free 的区别</h3><p>在使用的时候 new、delete 搭配使用，malloc、free 搭配使用。</p>
<p>malloc、free 是库函数，而new、delete 是关键字。<br>-new 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；malloc 在申请空间时，需要确定所申请空间的大小。<br>new 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；malloc 申请空间时，返回的是 void* 类型，需要进行强制类型的转换，转换为对象类型的指针。<br>new 分配失败时，会抛出 bad_alloc 异常，malloc 分配失败时返回空指针。<br>对于自定义的类型，new 首先调用 operator new() 函数申请空间（底层通过 malloc 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；delete 首先调用析构函数，然后调用 operator delete() 释放空间（底层通过 free 实现）。malloc、free 无法进行自定义类型的对象的构造和析构。<br>new 操作符从自由存储区上为对象动态分配内存，而 malloc 函数从堆上动态分配内存。（自由存储区不等于堆）</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209202147800.png"></p>
<p>自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。</p>
<p>那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。</p>
<p>malloc ：成功申请到内存，返回指向该内存的指针；分配失败，返回 NULL 指针。<br>new ：内存分配成功，返回该对象类型的指针；分配失败，抛出 bad_alloc 异常。</p>
<h3 id="delete-实现原理？delete-和-delete-的区别？"><a href="#delete-实现原理？delete-和-delete-的区别？" class="headerlink" title="delete 实现原理？delete 和 delete[] 的区别？"></a>delete 实现原理？delete 和 delete[] 的区别？</h3><p>delete 的实现原理：</p>
<p>首先执行该对象所属类的析构函数；<br>进而通过调用 operator delete 的标准库函数来释放所占的内存空间。<br>delete 和 delete [] 的区别：</p>
<p>delete 用来释放单个对象所占的空间，只会调用一次析构函数；<br>delete [] 用来释放数组空间，会对数组中的每个成员都调用一次析构函数。</p>
<p>参考 ：</p>
<p><a href="https://www.cnblogs.com/ywliao/articles/8116622.html" title="https://www.cnblogs.com/ywliao/articles/8116622.html">https://www.cnblogs.com/ywliao/articles/8116622.html</a></p>
]]></content>
      <categories>
        <category>c++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>五星 C++ 内存管理</title>
    <url>/2022/09/01/%E4%BA%94%E6%98%9FC++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20-2022-08-29/</url>
    <content><![CDATA[<p>C++ 内存分区：<strong>栈、堆、全局&#x2F;静态存储区、常量存储区、代码区</strong>。</p>
<span id="more"></span>

<p><strong>栈</strong>：存放函数的局部变量、函数参数、返回地址等，<strong>由编译器自动分配和释放</strong>。</p>
<blockquote>
<p>栈是线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，就是切换SS&#x2F;ESP寄存器。栈空间不需要在高级语言里面显式的分配和释放。</p>
</blockquote>
<p><strong>堆</strong>：动态申请的内存空间，就是由 **malloc **分配的内存块，<strong>由程序员控制它的分配和释放</strong>，如果程序执行结束还没有释放，操作系统会自动回收。（是可能会会释放，所以说，用完了一定记得要释放，不然会造成内存泄露）。</p>
<blockquote>
<p>堆一般由程序员分配释放，若不释放，程序结束时可能由OS回收。注意这里说是可能，并非一定。所以我想再强调一次，记得要释放！注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</p>
<p>当内存不再使用的时候，应使用free()函数将内存块释放掉。</p>
</blockquote>
<p><strong>全局区&#x2F;静态存储区（.bss 段和 .data 段）</strong>：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。</p>
<blockquote>
<p>解释一下静态变量</p>
<p>静态变量通过关键字static进行声明。</p>
<p>经static修饰过后的变量或者函数的作用域会发生变化。该变量存储在数据段上，可以改变变量的作用域和生命周期。</p>
<p><strong>全局静态变量</strong></p>
<p>在全局变量前面加上关键词static，全局变量就被定义成一个全局静态变量</p>
<p>（1）内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）</p>
<p>（2）初始化：未经初始化的全局静态变量会被程序自动初始化为0</p>
<p>（3）作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。</p>
<p><strong>局部静态变量</strong></p>
<p>在局部变量前面加上关键词static，局部变量就被定义成一个局部静态变量。</p>
<p>（1）内存中的位置：静态存储区</p>
<p>（2）初始化：未经初始化的局部静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）</p>
<p>（3）作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。</p>
<p><strong>C语言中使用静态函数的好处</strong></p>
<p>（1）静态函数会被自动分配在一个一直使用的存储区，直到退出程序，<strong>避免了调用函数的压栈出栈</strong>，速度快很多。</p>
<p>（2）static指函数的作用域仅局限于本文件。不<strong>用担心自己定义的函数是否会与其他文件的函数同名</strong></p>
</blockquote>
<p><strong>常量存储区（.data 段）</strong>：存放的是<strong>常量，不允许修改</strong>，程序运行结束自动释放。<br><strong>代码区（.text 段）</strong>：<strong>存放代码，不允许修改</strong>，但可以执行。编译后的二进制文件存放在这里。<br>说明：</p>
<p>从操作系统的本身来讲，以上存储区在内存中的分布是如下形式(从低地址到高地址)：</p>
<p><strong>.text 段 –&gt; .data 段 –&gt; .bss 段 –&gt; 堆 –&gt; unused –&gt; 栈 –&gt; env</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明：C++ 中不再区分初始化和未初始化的全局变量、静态变量的存储区，如果非要区分下述程序标注在了括号中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_var = <span class="number">0</span>; <span class="comment">// g_var 在全局区（.data 段）</span></span><br><span class="line"><span class="type">char</span> *gp_var;  <span class="comment">// gp_var 在全局区（.bss 段）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> var;                    <span class="comment">// var 在栈区</span></span><br><span class="line">    <span class="type">char</span> *p_var;                <span class="comment">// p_var 在栈区</span></span><br><span class="line">    <span class="type">char</span> arr[] = <span class="string">&quot;abc&quot;</span>;         <span class="comment">// arr 为数组变量，存储在栈区；&quot;abc&quot;为字符串常量，存储在常量区</span></span><br><span class="line">    <span class="type">char</span> *p_var1 = <span class="string">&quot;123456&quot;</span>;    <span class="comment">// p_var1 在栈区；&quot;123456&quot;为字符串常量，存储在常量区</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_var = <span class="number">0</span>;       <span class="comment">// s_var 为静态变量，存在静态存储区（.data 段）</span></span><br><span class="line">    p_var = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>); <span class="comment">// 分配得来的 10 个字节的区域在堆区</span></span><br><span class="line">    <span class="built_in">free</span>(p_var);                <span class="comment">// 因为使用了malloc堆的空间，由程序员自己释放掉</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：力扣 (LeetCode)</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/leetbook/read/cpp-interview-highlights/e4vkxv/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>四星 C++ 内存泄漏</title>
    <url>/2022/09/13/%E5%9B%9B%E6%98%9F%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%20%20%20%20-%20%20%20%202022-09-01/</url>
    <content><![CDATA[<p><strong>内存泄漏：由于疏忽或错误导致的程序未能释放已经不再使用的内存。</strong><br>进一步解释：</p>
<ul>
<li><p>并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。</p>
</li>
<li><p><strong>常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。</strong></p>
</li>
<li><p>使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete 释放内存，否则这块内存就会造成内存泄漏。</p>
</li>
<li><p>指针重新赋值</p>
<span id="more"></span></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">char</span> *p1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">p = np;</span><br></pre></td></tr></table></figure>

<p>开始时，指针 p 和 p1 分别指向一块内存空间，但指针 p 被重新赋值，导致 p 初始时指向的那块内存空间无法找到，从而发生了内存泄漏。</p>
<p>忘记了释放内存，造成内存泄露的后果</p>
<blockquote>
<p>含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。</p>
</blockquote>
<p><strong>再提一嘴内存溢出</strong></p>
<p>概念：内存溢出out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请一个int，但是给其存了long才能存得下的数，那就是内存溢出</p>
<blockquote>
<p>发生原因</p>
<ul>
<li><p>内存中加载的数据量过于庞大；</p>
</li>
<li><p>代码中存在<strong>死循环</strong>；</p>
</li>
<li><p>递归调用<strong>太深，导致栈溢出</strong>；</p>
</li>
<li><p><strong>内存泄漏</strong>最终导致内存溢出。</p>
</li>
</ul>
</blockquote>
<p><strong>再来一嘴野指针</strong></p>
<p>指向已经删除的对象或者申请访问受限内存区域的指针，称为野指针。</p>
<p>野指针与空指针不同，空指针是null。但是野指针并不知道指向了哪里，只能通过编程习惯规避。</p>
<blockquote>
<p>可能发生的原因：</p>
<ul>
<li><p>指针没有初始化：指针变量在被创建未初始化时，并不是空指针，它的缺省值是随机的，会乱指一气。所以指针变量在创建同时就应对其进行初始化，要么将指针设置为NULL，要么让其指向一个合法的内存。</p>
</li>
<li><p>指针释放之后未置空：有时指针在free或者delete之后未赋值NULL，有可能被误以为是合法的指针，不能进关注free和delete后的指针名，他们只是将指针所指向的内存空间释放掉而已，但并没有把指针自身消灭，此时，指针指向的就是“垃圾”内存。被释放掉内存空间的指针应该立即将其置为NULL，防止产生野指针。</p>
</li>
<li><p>指针操作超越变量作用域</p>
</li>
</ul>
<p>我觉得重点还是关注 没有初始化，以及本来指向了一块内存，然后指向的变量生命周期结束了，这个指针没有指向了，要及时置空。</p>
</blockquote>
]]></content>
      <categories>
        <category>c++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>四星 C++ 变量的区别</title>
    <url>/2022/09/04/%E5%9B%9B%E6%98%9F%20C++%20%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB-2022-08-30/</url>
    <content><![CDATA[<p>全局变量、局部变量、静态全局变量、静态局部变量的区别<br>C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。</p>
<span id="more"></span>
<p>从作用域看：</p>
<p><strong>全局变量：</strong> 具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量。</p>
<p><strong>静态全局变量：</strong>具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，<strong>它作用于定义它的文件里，不能作用到其它文件里</strong>，即被 static 关键字修饰过的变量具有文件作用域。这样即使<strong>两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</strong></p>
<p><strong>局部变量：</strong>具有局部作用域。它是自动对象（auto），在程序运行期间<strong>不是一直存在</strong>，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。</p>
<p><strong>静态局部变量：</strong>具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都<strong>一直存在</strong>，<strong>它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。</strong><br>从分配内存空间看：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于数据来说，声明和定义往往是同时存在的，比如下面的一行语句,既定义也声明了。</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//只声明不定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> data;</span><br><span class="line"><span class="comment">//对于函数来说，函数声明一般写在头文件中，函数的定义一般写在源文件中；</span></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">helloworld</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">helloworld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用变量之前必须声明，声明可以有多次，而定义只能有一次。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>静态存储区：</strong> 全局变量，静态局部变量，静态全局变量。<br><strong>栈：</strong> 局部变量。</p>
<p>静态变量和栈变量（存储在栈中的变量）、堆变量（存储在堆中的变量）的区别：<strong>静态变量会被放在程序的静态数据存储区（.data 段）中（静态变量会自动初始化），这样可以在下一次调用的时候还可以保持原来的赋值。</strong> 而栈变量或堆变量不能保证在下一次调用的时候依然保持原来的值。</p>
<p>静态变量是通过区分存放位置来保证其特殊的生命周期的。栈变量程序会自动释放。堆变量要由程序员自己释放。<br>静态变量和全局变量的区别：静态变量用 static 告知编译器，<strong>自己仅仅在变量的作用范围内可见</strong></p>
<blockquote>
<p>对于静态全局变量，只在该文件中生效，在其他文件中不生效，因此，在其他文件中，可以定义同名的静态全局变量。</p>
<p>对于静态局部变量，在局部函数体中，只要被初始化，就会一直存在，不会被释放。</p>
<p>全局变量，定义后，在其他文件中声明，就可以使用，不能存在同名的定义。并不需要引用头文件文件，但是依然可以在不同文件间共享变量和函数，这一切都是extern的功劳！</p>
</blockquote>
<p>××××</p>
<p>**全局变量定义在头文件中会出现什么问题 **</p>
<blockquote>
<p>如果在头文件中定义全局变量，当该头文件被多个文件 <code>include</code> 时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能再头文件中定义全局变量。</p>
</blockquote>
<p>include一个头文件，相当于把他带包写到了另一个文件，就会被多次定义。</p>
<p><strong>所以全局变量应该被定义在源文件中。</strong> 其他程序使用，利用extern进行声明。</p>
]]></content>
      <categories>
        <category>C++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>三星 C++ 在堆-栈上建立对象</title>
    <url>/2022/09/13/%E5%9C%A8%E5%A0%86-%20%E6%A0%88%E5%BB%BA%E7%AB%8B%E5%AF%B9%E8%B1%A1%20%20%20%20-%20%20%20%202022-08-31/</url>
    <content><![CDATA[<p>**如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？<br>**说明：C++ 中的类的对象的建立分为两种：<strong>静态建立、动态建立。</strong></p>
<p><strong>静态建立：</strong> 由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象。例如：A a;<br><strong>动态建立：</strong> 使用 new 关键字在堆空间上创建对象，底层首先调用 operator new() 函数，在堆空间上寻找合适的内存并分配；然后，调用类的构造函数创建对象。例如：A *p &#x3D; new A();</p>
<span id="more"></span>
<h2 id="1、类的构造函数"><a href="#1、类的构造函数" class="headerlink" title="1、类的构造函数"></a>1、类的构造函数</h2><blockquote>
<p>类的<strong>构造函数</strong>是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。</p>
<p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。</p>
<p>默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(); <span class="comment">//无参数的构造函数</span></span><br><span class="line"> <span class="comment">// A(int line); //有参数的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2、类的析构函数"><a href="#2、类的析构函数" class="headerlink" title="2、类的析构函数"></a>2、类的析构函数</h2><blockquote>
<p>类的<strong>析构函数</strong>是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。</p>
<p>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，<strong>它不会返回任何值，也不能带有任何参数。</strong> 析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(); <span class="comment">// 构造函数声明</span></span><br><span class="line">  ~<span class="built_in">A</span>(); <span class="comment">//析构函数声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3、限制对象建立在堆上"><a href="#3、限制对象建立在堆上" class="headerlink" title="3、限制对象建立在堆上"></a>3、限制对象建立在堆上</h2><p><strong>在栈上创建的必要条件是，构造函数和析构函数必须有外部访问权限。</strong></p>
<p>限制对象只能建立在堆上：</p>
<p>最直观的思想：避免直接调用类的构造函数，因为对象静态建立时，会调用类的构造函数创建对象。但是直接将类的构造函数设为私有并不可行，因为当构造函数设置为私有后，不能在类的外部调用构造函数来构造对象，只能用 new 来建立对象。但是由于 new 创建对象时，底层也会调用类的构造函数，将构造函数设置为私有后，那就无法在类的外部使用 new 创建对象了。因此，这种方法不可行。</p>
<p><strong>解决方法 1：</strong></p>
<p>将析构函数设置为私有。原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性。当析构函数设为私有时，编译器创建的对象就<strong>无法通过访问析构函数来释放对象的内存空间</strong>，因此，编译器不会在栈上为对象分配内存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destory</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>该方法存在的问题：</p>
<p>用 new 创建的对象，通常会使用 delete 释放该对象的内存空间，<strong>但此时类的外部无法调用析构函数</strong>(因为我们已经把析构函数设置为私有啦，所以我们需要自己写一个成员函数，来释放内存)，因此类内必须定义一个 destory() 函数，用来释放 new 创建的对象。</p>
<p><strong>无法解决继承问题，</strong> 因为如果这个类作为基类，析构函数要设置成 virtual，然后在派生类中重写该函数，来实现多态。但此时，析构函数是私有的，派生类中无法访问。</p>
</blockquote>
<p><strong>解决方法2：</strong></p>
<p>构造函数设置为 protected，并提供一个** public 的静态函数来完成构造**，而不是在类的外部使用 new 构造；将析构函数设置为 protected。原因：类似于单例模式，<strong>也保证了在派生类中能够访问析构函数</strong>。通过调用 create() 函数在堆上创建对象。</p>
<blockquote>
<p>private: 只能由该类中的函数、其友元函数访问,不能被任何其他访问，该类的对象也不能访问.<br>protected: 可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问<br>public: 可以被该类中的函数、子类的函数、其友元函数访问,也可以由该类的对象访问</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> A *<span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destory</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4、限制对象建立在堆上"><a href="#4、限制对象建立在堆上" class="headerlink" title="4、限制对象建立在堆上"></a>4、限制对象建立在堆上</h2><p>由于我们利用new来分配堆空间，再调用类的构造函数构建对象。因此，我们重载 operate new()为私有，就可以限制对象建立在堆上。同时由于重载operate new（）为私有，也得重载operate delete（）；</p>
<blockquote>
<p>new和delete是C++中的表达式，用于创建一个新的对象。它们是对堆中的<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020" title="内存">内存</a>进行申请和释放，而且<strong>这两个都是不能被重载的</strong>。<strong>要实现不同的内存分配行为，需要重载operator new和operator delete而不是new和delete。</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> t)</span> </span>&#123;&#125;    <span class="comment">// 注意函数的第一个参数和返回值都是固定的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span> </span>&#123;&#125; <span class="comment">// 重载了 new 就需要重载 delete</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p><strong>1、对象建立的两种方式：</strong></p>
<p>静态建立：直接调用类的构造函数创建对象。此时对象在栈上。</p>
<p>动态建立：使用new关键字，再调用类的构造函数，A *p &#x3D; new A()。此时对象在堆上。</p>
<p><strong>2、限制对象建立在栈上</strong></p>
<p>1、设置析构函数为私有。缺点：①需要写一个销毁的成员函数用于释放内存，因为用于销毁对象的析构函数私有了，不能被外部调用。 ②无法继承</p>
<p>2、将构造函数和析构函数全部设为protected通过<strong>调用成员函数动态创建和删除(这个函数得自己写)。</strong></p>
<p>**3、限制对象建立在堆上 **</p>
<p>重载 operator new()和operator delete（）为私有</p>
]]></content>
      <categories>
        <category>c++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>四星 C++ 程序编译过程</title>
    <url>/2022/08/31/%E5%9B%9B%E6%98%9FC++%20%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%20-%202022-08-28/</url>
    <content><![CDATA[<p>编译过程可以分为以下三个过程：编译（编译预处理、编译、优化），汇编，链接。<br>其中编译又可以分为编译预处理以及编译优化，就可以划分为四部分。</p>
<span id="more"></span>

<h2 id="1、编译预处理"><a href="#1、编译预处理" class="headerlink" title="1、编译预处理"></a>1、编译预处理</h2><p>编译预处理：处理以 # 开头的指令；</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SOMEFILE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOMEFILE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta">#program once</span></span><br></pre></td></tr></table></figure>

<h2 id="2、编译、优化"><a href="#2、编译、优化" class="headerlink" title="2、编译、优化"></a>2、编译、优化</h2><p>将源码 .cpp 文件翻译成 .s 汇编代码；</p>
<h2 id="3、汇编"><a href="#3、汇编" class="headerlink" title="3、汇编"></a>3、汇编</h2><p>将汇编代码 .s 翻译成机器指令 .o 文件；</p>
<h2 id="4、链接"><a href="#4、链接" class="headerlink" title="4、链接"></a>4、链接</h2><p>汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。</p>
<p><strong>链接包括静态链接和动态链接</strong></p>
<p><strong>静态链接</strong>：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</p>
<p>通俗的讲：静态链接将程序调用的库一起打包到可执行文件中，这样执行时候就不用调用其他的库，速度快。但是，可能多个文件都链接了同一个库，那么这个库就被打包了很多次，造成了该空间上的浪费。如果这个库更新了的话，整个程序需要重新编译。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208302038882.png" alt="静态链接"></p>
<p><strong>动态链接</strong>：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</p>
<p>通俗的讲：动态链接是在程序执行时候才引入的库，因此方便更新。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208302038200.png" alt="动态链接"></p>
<p>二者的优缺点：</p>
<p>静态链接：<strong>浪费空间，</strong>每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序<strong>（更新困难）</strong>；优点就是执行的时候运行<strong>速度快，</strong> 因为可执行程序具备了程序运行的所有内容。<br>动态链接：<strong>节省内存、更新方便</strong>，但是动态链接是在程序运行时，每次执行都需要链接，<strong>相比静态链接会有一定的性能损失。</strong></p>
]]></content>
      <categories>
        <category>C++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 详解多重继承和虚继承、多重继承可能出现的问题</title>
    <url>/2022/10/09/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E7%BB%A7%E6%89%BF%20%20%20%20-%20%20%20%202022-10-08/</url>
    <content><![CDATA[<p>多重继承可能会导致命名冲突和数据冗余，通过虚继承可以解决命名冲突问题。</p>
<span id="more"></span>

<h2 id="多重继承可能会导致的问题"><a href="#多重继承可能会导致的问题" class="headerlink" title="多重继承可能会导致的问题"></a>多重继承可能会导致的问题</h2><p>多重继承是从派生类从多个基类中继承而来。所以可能会出现<strong>数据冗余</strong>以及<strong>命名冲突</strong>的问题。</p>
<p>例如   有基类A ，  B、C由A继承而来，D多重继承了A和B，那么D中将会出现命名冲突的问题，因为B、C中都包含基类A 中的成员。这导致出现了菱形继承关系</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202210091501424.png"></p>
<p><strong>解决方法1：声明出现冲突的成员变量来源于哪个类</strong></p>
<p>var1是来自基类A的对象，被B、C继承了，D又多重继承了B、C，那么在定义一个D类对象，想要对var1进行赋值的时候，需要声明这个var1是来自继承的哪一个类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_var1</span><span class="params">(<span class="type">int</span> tmp)</span> </span>&#123; Base2::var1 = tmp; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方法2：虚继承</strong></p>
<p>使用虚继承的目的：保证存在命名冲突的成员变量在派生类中只保留一份，即使间接基类中的成员在派生类中只保留一份。在菱形继承关系中，间接基类称为虚基类，直接基类和间接基类之间的继承关系称为虚继承。</p>
<p>实现方式：在继承方式前面加上<code> virtual </code>关键字</p>
<p>类的继承关系</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202210091501680.png"></p>
<p>问题：命名冲突的成员变量在派生类中只保留一份，那么所有的类中的成员变量都统一了直接？从原理角度来讲应该是这样。</p>
<p>详细补充一些内容：<br>虚继承使派生类除了继承基类成员作为自己的成员之外，内部还会有一份内存来保存哪些是基类的成员。当Derive继承Base2和Base3之后，编译器根据虚继承多出来的内存，查到Base2和Base3拥有共同的基类的成员，就不会从Base2和Base3中继承这些，而是直接从共同的基类中继承成员，也就是说，Derive直接继承base的成员，然后再继承Base2和Base3各自新增的成员。这样，Derive就不会继承两份内存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 间接基类，即虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接基类 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base1 <span class="comment">// 虚继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接基类 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base1 <span class="comment">// 虚继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_var1</span><span class="params">(<span class="type">int</span> tmp)</span> </span>&#123; var1 = tmp; &#125; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_var2</span><span class="params">(<span class="type">int</span> tmp)</span> </span>&#123; var2 = tmp; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_var3</span><span class="params">(<span class="type">int</span> tmp)</span> </span>&#123; var3 = tmp; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_var4</span><span class="params">(<span class="type">int</span> tmp)</span> </span>&#123; var4 = tmp; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> var4;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derive d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>上传项目至Github并修改init主分支为main</title>
    <url>/2022/08/29/%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E8%87%B3GitHub,%E5%B9%B6%E4%BF%AE%E6%94%B9init%E4%B8%BB%E5%88%86%E6%94%AF%E4%B8%BAmain/</url>
    <content><![CDATA[<p>摘要：本文介绍了如何将本地项目上传至GitHub，并修改init主分支为main。</p>
<span id="more"></span>
<h2 id="1、创建项目"><a href="#1、创建项目" class="headerlink" title="1、创建项目"></a>1、创建项目</h2><p>首先，我们需要在LeetCode创建一个自己的项目，并利用Add readme自动初始化项目。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208291939784.png"></p>
<p>本文默认已经配置了SSH公钥。</p>
<h2 id="2、修改init的默认分支"><a href="#2、修改init的默认分支" class="headerlink" title="2、修改init的默认分支"></a>2、修改init的默认分支</h2><p>在2020年10月1起，github默认主分支从master更名为main，以上提交方式会默认创建一个master分支，为保持一致性，可将本地git init的时候默认分支修改为main，执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git --version    查看版本</span><br><span class="line">git config --global init.defaultBranch main   git在2.28.0上，重新设置git默认分支为main</span><br></pre></td></tr></table></figure>

<p>如果不小心创建了master分支，可以执行命令删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">删除本地分支：git branch -d 分支名称</span><br><span class="line">强制删除本地分支：git branch -D 分支名称</span><br><span class="line">删除远程分支：git push origin --delete 分支名称</span><br></pre></td></tr></table></figure>

<h2 id="3、第一次项目提交"><a href="#3、第一次项目提交" class="headerlink" title="3、第一次项目提交"></a>3、第一次项目提交</h2><h3 id="①-初始化git"><a href="#①-初始化git" class="headerlink" title="① 初始化git"></a>① 初始化git</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<h3 id="②-添加文件到缓存区"><a href="#②-添加文件到缓存区" class="headerlink" title="② 添加文件到缓存区"></a>② 添加文件到缓存区</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208291939230.png"></p>
<h3 id="③-提交说明"><a href="#③-提交说明" class="headerlink" title="③ 提交说明"></a>③ 提交说明</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;需要注释的内容&quot;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208291939775.png"></p>
<h3 id="④-链接到项目"><a href="#④-链接到项目" class="headerlink" title="④ 链接到项目"></a>④ 链接到项目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin http://xxxxxxxxx.git   //本地仓库和远程github关联</span><br></pre></td></tr></table></figure>

<h3 id="⑤-第一次提交需要拉取项目中的readme"><a href="#⑤-第一次提交需要拉取项目中的readme" class="headerlink" title="⑤ 第一次提交需要拉取项目中的readme"></a>⑤ 第一次提交需要拉取项目中的readme</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull --rebase origin main</span><br></pre></td></tr></table></figure>

<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208291939043.png"></p>
<h3 id="⑥-推送至远程GIT-项目合并"><a href="#⑥-推送至远程GIT-项目合并" class="headerlink" title="⑥ 推送至远程GIT 项目合并"></a>⑥ 推送至远程GIT 项目合并</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208291939631.png"></p>
<p>特地强调一下 -u 操作。在我们第一次提交git的时候使用这个参数，在以后我们要进行二次提交的时候，就可以用</p>
<p><code>git push</code>代替 <code>git push origin main</code>.</p>
<h2 id="4、更新结果"><a href="#4、更新结果" class="headerlink" title="4、更新结果"></a>4、更新结果</h2><p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208291939457.png"></p>
<h2 id="5、下一次提交？"><a href="#5、下一次提交？" class="headerlink" title="5、下一次提交？"></a>5、下一次提交？</h2><p>我们希望持续的维护一个项目，就会对代码进行修改，修改后，再次提交。</p>
<p>为了展示如何修改，修改项目中的文件，并增加新的文件 1、两数之和。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208291939832.png"></p>
<p>在本地的代码指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status   //查看有哪些文件修改</span><br><span class="line">git add 文件名   //哪些文件要提交</span><br><span class="line">git add .       //全部添加到暂存区</span><br><span class="line">git add -A        //所有修改、增加、删除都添加到暂存区</span><br><span class="line">git commit  -m &quot;注释&quot;     //提交 </span><br><span class="line">git push      //推送</span><br></pre></td></tr></table></figure>

<p>如果想直接提交所有修改文件，命令可以更简洁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -a  -m &quot;注释&quot;    //提交所有修改</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>这样就完成了再次提交。</p>
<p>本文到此就结束啦，希望对你有所帮助。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>将构造函数/析构函数设置为私有（如何构建单例模型）</title>
    <url>/2022/09/14/%E5%B0%86%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%A7%81%E6%9C%89%EF%BC%88%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%9E%8B%EF%BC%89/</url>
    <content><![CDATA[<p>两种使用场景：第一种只希望构建子类的对象，而不构建基类的对象。第二种，构建单例模型，利用静态成员函数生成类的实例</p>
<span id="more"></span>
<h2 id="第一种使用情景："><a href="#第一种使用情景：" class="headerlink" title="第一种使用情景："></a>第一种使用情景：</h2><p>对于类A 不想让外面的用户直接构造一个类A的对象，而是希望用户只构造类A的子类，那么可以将A的构造&#x2F;析构函数声明为protected,将类A的子类的构造函数&#x2F;析构函数声明为public，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;call A test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125; </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>: <span class="built_in">B</span>()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a; <span class="comment">// error</span></span><br><span class="line">    B b; <span class="comment">// ok</span></span><br><span class="line">    b.<span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基类的构造函数被protected，外部无法访问，也就无法构造示例。但子类将基类的public和protected成员都继承为public，子类可以调用基类的函数。</p>
<h2 id="第二种使用场景："><a href="#第二种使用场景：" class="headerlink" title="第二种使用场景："></a>第二种使用场景：</h2><p>单例模型</p>
<p>当构造函数&#x2F;析构函数被声明为private，那么无法构造类的对象，就只能使用类的内部的函数构造类的对象了。但是类的成员函数需要有类的对象才能够调用，外部不能直接构造一个对象出来。因此，我们需要将构造对象的函数声明为<code>static</code>，这样我们通过类就可以直接访问和调用静态成员函数。静态成员函数可以通过类直接调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">data</span>(<span class="number">10</span>)&#123; cout &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123; cout &lt;&lt; <span class="string">&quot;~A&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> A&amp; <span class="title">Instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> A a;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A&amp; ra = A::<span class="built_in">Instance</span>();</span><br><span class="line">    ra.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>定义一个单例类：</p>
<ol>
<li><p>私有化它的构造函数，以防止外界创建单例类的对象；</p>
</li>
<li><p>使用类的私有静态指针变量指向类的唯一实例；</p>
</li>
<li><p>使用一个公有的静态方法获取该实例。</p>
</li>
</ol>
<p><strong>参考文献</strong>：</p>
<p><a href="https://blog.csdn.net/fly542/article/details/8055207">https://blog.csdn.net/fly542/article/details/8055207</a></p>
]]></content>
      <categories>
        <category>c++常用知识</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉SLAM十四讲-第三讲：三维空间刚体运动</title>
    <url>/2022/08/28/%E8%A7%86%E8%A7%89SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2%E4%B9%8B%E7%AC%AC%E4%B8%89%E8%AE%B2/</url>
    <content><![CDATA[<h2 id="第三讲：三维空间刚体运动"><a href="#第三讲：三维空间刚体运动" class="headerlink" title="第三讲：三维空间刚体运动"></a>第三讲：三维空间刚体运动</h2><p><strong>利用旋转+平移描述三维空间刚体的运动</strong></p>
<span id="more"></span>

<p>向量在一个坐标系下的坐标表示：</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321796.png"></p>
<p>即在以基底为（e1,e2,e3）的坐标系下，向量的坐标为（a1,a2,a3）</p>
<blockquote>
<p>📌向量的内积，即向量的点乘。描述了两个向量间的投影关系，</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321495.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321030.png"></p>
</blockquote>
<blockquote>
<p>📌向量的外积，即向量的叉乘。得到了第三个向量，这个向量，垂直于这两个向量。</p>
<p>这个关系描述子向量间的旋转</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321232.png"></p>
<p>其中n是a和b构成的平面的单位向量</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321246.png"></p>
<p>外积只对三维向量存在定义。</p>
<p>上式中的定义，将外积转化为了矩阵的乘法，也是成立的。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321069.png"></p>
<p>在旋转向量的方向就是a x b的方向，大小由ab的夹角决定。 右手法则，攥住旋转轴，手指的旋转方向就是旋转方向，大小就是这个旋转向量的大小。因此，由向量的外积可以表示一个旋转，一个轴代表方向，一个夹角，后面会引入旋转向量。</p>
</blockquote>
<blockquote>
<p>📌<strong>坐标系间的欧式变换</strong></p>
<p>相机运动是一个刚体运动，<strong>它保证了同一个向量在各个坐标系下的长度和夹角都不会</strong></p>
<p>发生变化。这种变换称为欧氏变换。</p>
<p><strong>这种变换最大的特点就是改变物体的空间位置但是不改变物体的形状、大小，即不改变向量的方向和大小。</strong></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321564.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321019.png"></p>
<p>旋转矩阵是行列式为1的正交矩阵，正交矩阵是本身转置等于本身逆的矩阵。</p>
<p>旋转矩阵的逆描述了一个相反的旋转。</p>
<hr>
<p>因为平移向量的存在，这里的变换不是一个 线性关系，因此引入齐次坐标，重写得到<strong>变化矩阵</strong></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321926.png"></p>
<p>在三维向量的末尾添加一个1，变成四维向量，称为齐次坐标。这是一种数学技巧，这允许我们将变换变成了一个线性变换。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321055.png"></p>
<p><strong>同样，T的逆变换也代表相反的变换。</strong> 变换矩阵属于特殊的欧式群，区别于旋转矩阵，不存在转置等于逆变换。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321282.png"></p>
<p>自己的推导证明如下：</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321393.jpg"></p>
<p>变换矩阵的逆矩阵R部分直接转置，但是t部分不能直接加一个负号。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321727.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322743.png"></p>
<p>t在求逆后不是一个单纯的负号，是因为逆变换的过程中参考系发生了变化。默认SLAM，先旋转再平移，则，Tab，Rab旋转后，在平移tab，这里tab参考的是Rab旋转后的坐标系，即虚线表示的坐标系。反过来，B旋转Rba，即Rab的转置（逆），这里的状态是与A坐标系差一个平移tba。tab的参考系是Rab点乘A，但现在的参考系是Rba点乘B，所以要将tab变换到Rba点乘B下面，在进行负变换，因此对-tab做成Rab的转置（逆）。</p>
<p>再从运算的角度进行分析：</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322432.png"></p>
<p>变换的合成是不断的左乘位姿变换矩阵。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322374.png"></p>
<p>APE，绝对位姿误差：每个时刻的位姿和真实位姿之间的误差计算。</p>
<p>RPE，相对位姿误差：相邻时刻的相对位姿变化与真实相对位姿变换间的误差</p>
<p>有关RPE和APE可以进一步参考</p>
<p><a href="http://zhaoxuhui.top/blog/2021/05/14/APE-RPE-ATE-RTE-Mmetric-in-SLAM.html" title="http://zhaoxuhui.top/blog/2021/05/14/APE-RPE-ATE-RTE-Mmetric-in-SLAM.html">http://zhaoxuhui.top/blog/2021/05/14/APE-RPE-ATE-RTE-Mmetric-in-SLAM.html</a></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322658.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322721.png"></p>
<p>根据计算方式，其实我们也就很容易知道RPE的好处了，RPE只使用位姿的变化而不关心估计的绝对位姿，因此消除了估计的绝对位置对于最终结果的影响。APE中每个绝对位姿都是相对于绝对坐标系的，因此含有绝对位置的影响。</p>
</blockquote>
<blockquote>
<p>📌Eigen&#x2F;库的理论实践</p>
<p>Eigen库的神奇之处在于它是一个完全用头文件搭建的库，没有.so或.a 那样的二进制文件。</p>
<p>我们在使用时，只需引入 Eigen 的头文件即可，不需要链接它的库文件（因为它没有库文</p>
<p>件）。</p>
<p>重复一遍，因为 Eigen 库只有头文件，我们不需要再用 tartget_link_libraries 语句将程序链接到库上。不过，对于其他大部分库，多数时候需要用到链接命令。</p>
</blockquote>
<blockquote>
<p>📌<strong>旋转向量</strong></p>
<p>为什么要引入旋转向量？</p>
<p>A：旋转使三自由度运动，平移也是三自由度运动，为了描述一个六自由度变换，变换矩阵采用了16个元素，造成表达非常不紧凑，同理旋转矩阵。</p>
<p>旋转矩阵自身带有约束：它必须是个正交矩阵，且行列式为 1。<strong>变换矩阵也是如此（因为变换矩阵包含了旋转矩阵）。</strong> 当我们想要估计或优化一个旋转矩阵&#x2F;变换矩阵时，这些约束会使得求解变得更困难。</p>
<p>为了表达更加紧凑，引入了旋转向量。</p>
<p>任意旋转都可以用一个旋转轴和一个旋转角来刻画。于是，我们可以使用一个向量，<strong>其方向与旋转轴一致，而长度等于旋转角</strong>。这种向量，称为旋转向量。</p>
<p>由旋转向量到旋转矩阵的过程由<strong>罗德里格斯公式（Rodrigues’s Formula ）</strong> 表明：</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322494.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322233.png"></p>
<p>旋转矩阵特征值为1时对应的特征向量，|R-λE|&#x3D;0，特征值为1，说明旋转矩阵为单位矩阵，说明在这个特征向量（解）上没有旋转变化，转轴上的旋转没有旋转变化，所以对应的特征向量就是转轴。求解矩阵R特征值为1时候的特征向量就得到了旋转轴。利用式3.16求得转角，就获得了<strong>旋转向量。</strong></p>
<p>这里共涉及到两种变换，假设一个旋转轴为 n ,角度为θ的旋转。</p>
<ol>
<li><p>从旋转向量到旋转矩阵的变换：罗德里格斯公式。</p>
</li>
<li><p>从旋转矩阵到旋转向量的变换。 &amp;#x20;</p>
<p>①.对 θ :  公式3.16</p>
<p>②.对 n ：转轴 n ，是矩阵 R 特征值1对应的特征向量。</p>
<p><img data-src="/image/image_nsoQdMmLFK.png"></p>
</li>
</ol>
</blockquote>
<blockquote>
<p>📌<strong>欧拉角</strong></p>
<p>无论是旋转矩阵还是旋转向量，都是数学的形式，不能很直观的反应旋转的形式。欧拉角将旋转分解为了绕三个固定轴的旋转。</p>
<p>欧拉角当中比较常用的一种，便是用“偏航-俯仰-滚转”（yaw-pitch-roll）三个角度来描述一个旋转的。它等价于 ZY X 轴的旋转。在右手坐标系中进行记忆：</p>
<ol>
<li><p>绕物体的 Z 轴旋转，得到偏航角 yaw；</p>
</li>
<li><p>绕旋转之后的 Y 轴旋转，得到俯仰角 pitch；</p>
</li>
<li><p>绕旋转之后的 X 轴旋转，得到滚转角 roll。</p>
</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322394.png"></p>
<p><img data-src="/image/image_icJyhksFNx.png"></p>
<hr>
<p>欧拉角中最大的问题是万向锁，这种现象被称为具有奇异性，例如应用zxy的转法，首先改变偏航角，再改变滚转角，再改变俯仰角。如果第二次旋转，滚转角为90度，则第三次旋转将会变得与第一次旋转相同，就丢失了一个自由度。相当于第二次如果转90度，x就跑到了原本z轴的位置，那么第三次旋转就和第一次一样，那么就变成了三次旋转只转了两次。丢失了一个自由度。其他欧拉角旋转方式也具有类似的问题。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322362.png"></p>
<p>欧拉角常用于人机交互，在SLAM中不常用。</p>
</blockquote>
<blockquote>
<p>📌<strong>四元数</strong></p>
<p>三维旋转是一个三维流形，想要无奇异性地表达它，用三个量是不够的。</p>
<p><strong>四元数是一种扩展的复数。</strong> 一个实部和三个虚部。</p>
<p>实部为0，虚四元数，虚部为0，实四元数</p>
<p>因此，在四元数中，任意的旋转都可以由两个互为相反数的四元数表示。</p>
<p>四元数的共轭是把虚部取成相反数</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322828.png"></p>
<p>四元数共轭与自己本身相乘，会得到一个实四元数，其实部为模长的平方:</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322894.png"></p>
<p>两个单位四元数相乘后依然是单位四元数。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322950.png"></p>
<p>单位四元数的逆和共轭相等</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322786.jpg"></p>
<p><strong>用四元数表示旋转</strong></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322493.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322067.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322697.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262323777.jpg"></p>
<p>旋转矩阵、旋转向量、四元数之间可以相互转化。由于上述推算的方法需要计算arcos不太划算，所以，采用另一种方法跳过这个计算，如下：</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262323373.png"></p>
<p>由于 q 和 −q 表示同一个旋转，事实上一个 R 对应的四元数表示并不是唯一的。</p>
</blockquote>
<blockquote>
<p>📌<strong>相似、仿射、射影变换</strong></p>
<p>欧氏变换保持了向量的长度和夹角，是一个刚体运动，形状是不变的。</p>
<p><strong>相似变换</strong>比欧氏变换多了一个自由度，允许物体进行均匀的缩放。但是是成比例的。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262323336.png"></p>
<p><strong>仿射变换</strong>只要求A是一个可逆矩阵而不必是正交矩阵，仿射变换也叫正交投影，经过仿射变换之后，立方体就不再是方的了，但是各个面仍然是平行四边形。保持了平直性和平行性，但是角度会变。变换后直线还是直线，圆弧还是圆弧。平行线还是平行线，直线上点的位置顺序不变</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262323413.png"></p>
<p><strong>射影变换</strong>是最一般的变化。二维8自由度，三维15自由度。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262323362.png"></p>
<p><strong>从真实世界到相机照片的变换是一个射影变换。如果相机的焦距为无穷远，那么这个变换则为仿射变换。</strong></p>
<p>三维空间下，四种变换的自由度区别。</p>
<p>欧式变换   6自由度   三个轴，每个轴有平移和旋转，3x2&#x3D;6</p>
<p>相似变换   7自由度  成比例缩放  多加一个自由度   7</p>
<p>仿射变换   12 自由度 三个轴，每个轴缩放、旋转、平移、倾斜  3x4&#x3D;12 如果是2维，则是6自由度</p>
<p>&amp;#x20;             另一个角度，从公式去理解 A9个元素，t三个元素，12个元素变换都影响结果。因此  &amp;#x20;</p>
<p>&amp;#x20;             是12自由度</p>
<p>射影变换  从公式来看v不等于0时，这个变换矩阵是是齐次的。否则右下角一直为0，也没变化，没意义。那么4x4&#x3D;16的矩阵里，只有1 不变，那么是15自由度。如果对于二维空间，那齐次矩阵就变成了3x3-1&#x3D;8，因此二维空间的射影变换是8自由度。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262323054.png"></p>
<p>二维中，一个点有两个自由度。</p>
<p>真实世界拍照是射影变换，如果焦距无限远就变成了仿射变换。射影变换只保留了点的共线性，平行性消失了。</p>
</blockquote>
<blockquote>
<p>📌Eigen使用总结</p>
</blockquote>
<blockquote>
<p>📌<strong>值得做的习题，证明方面的。</strong></p>
<ol>
<li><p>验证旋转矩阵是正交矩阵。</p>
</li>
<li><p>&amp;#x20;一般线程方程 Ax &#x3D; b 有哪几种做法？你能在 Eigen 中实现吗？</p>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>视觉SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉SLAM十四讲-第二讲：初识SLAM</title>
    <url>/2022/08/26/%E8%A7%86%E8%A7%89SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2%E4%B9%8B%E7%AC%AC%E4%BA%8C%E8%AE%B2/</url>
    <content><![CDATA[<p>本文主要介绍视觉SLAM十四讲中第二讲的关键内容。</p>
<span id="more"></span>
<h2 id="第二讲：初识SLAM"><a href="#第二讲：初识SLAM" class="headerlink" title="第二讲：初识SLAM"></a>第二讲：初识SLAM</h2><p>一类传感器是<strong>携带于机器人本体上</strong>的，例如机器人的轮式编码器、相机、激光等等 ——通过间接测量数据推算位置，好处是对环境没有提出要求，适用于位置环境。</p>
<p>一类是<strong>安装于环境中</strong>的，例如前面讲的导轨、二维码标志等等。   —— 约束了外界环境，限制了使用范围</p>
<blockquote>
<p>📌</p>
<p><strong>单目相机</strong>是三维空间的二维投影，因此，如果想恢复三维结构，必须移动相机的视角。</p>
<p>因此，<strong>单目相机平移之后才能计算深度，并且无法确定真实尺度</strong>，问题的本质在于通过单张图像无法确定深度。</p>
</blockquote>
<blockquote>
<p>📌<strong>双目相机</strong>和<strong>深度相机</strong>，目的在于通过某种手段测量物体距离我们的距离，回复距离信息，因此场景的三维结构可以通过单张图线回复，也就消除了尺度不确定性。</p>
<p>双目相机测量到的深度范围与基线相关。基线距离越大，能够测量到的就越远</p>
<p><strong>双目或多目相机的缺点</strong>是配置与标定均较为复杂，其深度量程和精度受双目的基线与分辨率限制，而且视差的计算非常消耗计算资源</p>
<p><strong>深度相机</strong>（又称 RGB-D 相机)右开始兴起的一种相机，它最大的特点是可以通过红外结构光或 Time-of-Flight（ToF）原理，像激光传感器那样，通过主动向物体发射光并接收返回的光，测出物体离相机的距离。<strong>区别于双目相机是采用计算的方式获得深度，深度相机是通过物理方式，避免了大量的计算。</strong></p>
</blockquote>
<p>视觉里程计只计算相邻时刻的运动，而和再往前的过去的信息没有关联。仅通过视觉里程计估计轨迹，将不可避免的出现累积漂移。每次估计都会有一定的误差，由于里程计只估计相邻时刻的运动，先前时刻的误差将会传递到下一时刻，导致一段时间后估计的轨迹不再准确。</p>
<p>后端优化主要指处理 SLAM 过程中噪声的问题。后端优化要考虑的问题，就是如何从这些带有噪声的数据中，估计整个系统的状态，以及这个状态估计的不确定性有多大——这称为最大后验概率估（Maximum-a-Posteriori，MAP）。</p>
<p>为了实现回环检测，我们需要让机器人具有识别曾到达过的场景的能力。</p>
<blockquote>
<p>📌<strong>SLAM问题的数学表述</strong></p>
<p><img data-src="https://s2.loli.net/2022/08/26/HR8BbFdckGSAUpP.png" alt="SLAM运动和观测方程.png"></p>
<p>方程1是运动方程，方程2是观测方程</p>
<p>其中uk代表传感器输入，z代表传感器观测，y代表路标。</p>
<p>运动方程:  相机是六自由度姿态，两次位姿之间的关系相差一个旋转矩阵。</p>
<p>观测方程：z是在xk位置观测到yj所产生的观测数据。例如，在xk看到一个特征点，获得他的像素坐标[u,v]，由三维空间点获得像素坐标，这是<strong>相机模型。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>视觉SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>解决typora提示:This beta version of Typora is expired</title>
    <url>/2022/08/27/%E8%A7%A3%E5%86%B3typora%E6%8F%90%E7%A4%BAThis%20beta%20version%20of%20Typora%20is%20expired/</url>
    <content><![CDATA[<p>解决typora提示This beta version of Typora is expired, please download and install a newer version<br>自从typora付费之后也没有怎么使用，后来做git仓库+picgo+typora联动的时候，再次打开typora，弹出了以下窗口：</p>
<span id="more"></span>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208271020322.png" alt="ERROR提示"></p>
<p>我重新下载了付费版本的typora然后然后开启了15天尝鲜。但是我发现之后再想用typora打开md文档的时候依然会出现这个提示框，并且无论是点击确定还是×掉都依然会跳转到typora的安装界面。</p>
<p>这个错误提示大概的意思就是beta版本的typora已经过，需要下载最新版本。</p>
<p>在网上查找了一圈解决办法，目前通过修改注册表解决了我的问题。</p>
<p>以下是解决步骤：</p>
<p>1、win+r 打开运行窗口 &amp;#x20;<br>2、在搜索栏输入regedit，回车后打开注册表 &amp;#x20;<br>3、在注册表中找到：计算机\HKEY_CURRENT_USER\Software\Typora &amp;#x20;<br>4、鼠标右键Typora，选择权限 &amp;#x20;<br>5、选择Administraors，将下面的权限选择为拒绝</p>
<p>点击应用的时候可能会出现提醒，点确定就行了。最后保存设置。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208271021324.png" alt="修改typora权限"></p>
<p>6、重新打开typora，就可以正常应用了。</p>
<p>以上就是问题的解决方法。</p>
]]></content>
      <categories>
        <category>一些奇奇怪怪的问题之windows</category>
      </categories>
      <tags>
        <tag>typora</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ 面向对象的三大特性详解—封装、继承、多态</title>
    <url>/2022/09/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%20%20%20%20-%20%20%20%202022-09-09/</url>
    <content><![CDATA[<p>面向对象：对象是指具体的某一个事物，这些事物的抽象就是类，类中包含数据（成员变量）和动作（成员方法）。</p>
<p>面向对象的三大特性：</p>
<p><strong>封装：</strong> 将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。<br><strong>继承：</strong> 子类继承父类的特征和行为，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 final 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。<br><strong>多态：</strong> 多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。</p>
<span id="more"></span>
<p>封装可以使得代码模块化，继承可以扩展已经存在的代码，目的都是为了代码重用。多态的目的是为了接口重用。</p>
<h2 id="1、继承"><a href="#1、继承" class="headerlink" title="1、继承"></a>1、继承</h2><p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">child</span>: <span class="keyword">public</span> parent</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中<code>public</code>可以替换为<code>protect</code>、<code>private</code></p>
<p>类型决定了子类将会把基类的内容继承为什么类型。</p>
<h3 id="1-1-继承类型"><a href="#1-1-继承类型" class="headerlink" title="1.1 继承类型"></a>1.1 继承类型</h3><p>我们几乎不使用 <strong>protected</strong> 或 <strong>private</strong> 继承，通常使用 <strong>public</strong> 继承。当使用不同类型的继承时，遵循以下几个规则：</p>
<ul>
<li><p><strong>公有继承（public）：当一个类派生自</strong>公有基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</p>
</li>
<li><p><strong>保护继承（protected）：</strong> 当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</p>
</li>
<li><p><strong>私有继承（private）：当一个类派生自</strong>私有基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</p>
</li>
</ul>
<hr>
<h3 id="1-2访问权限总结："><a href="#1-2访问权限总结：" class="headerlink" title="1.2访问权限总结："></a>1.2访问权限总结：</h3><p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209202145062.png"></p>
<p>因此，如果基类成员不想被派生类的成员函数访问，应该在基类中声明为private。</p>
<p>一个派生类继承了所有的基类方法，但下列情况除外：</p>
<ul>
<li><p>基类的构造函数、析构函数和拷贝构造函数。</p>
</li>
<li><p>基类的重载运算符。</p>
</li>
<li><p>基类的友元函数。</p>
</li>
</ul>
<hr>
<h3 id="1-3多继承"><a href="#1-3多继承" class="headerlink" title="1.3多继承"></a>1.3多继承</h3><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p>
<p>C++ 类可以从多个类继承成员，语法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;派生类名&gt;:&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2、多态"><a href="#2、多态" class="headerlink" title="2、多态"></a>2、多态</h2><p>C++多态(polymorphism)是通过虚函数来实现的.</p>
<p>当类存在多层的层次结构，并且类之间是通过继承关联的时，<strong>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</strong></p>
<blockquote>
<p>📌简单来说就是一个基类被派生为多个子类，子类中对基类中的函数进行了重写。我们希望利用子类的指针或者引用可以实现调用重写的函数，而不是基类中原本的函数，这时候，我们需要对基类中和子类中同名的函数前加上关键字<code>virtual</code>。这里我们应该称为是函数的重写。</p>
</blockquote>
<p>虚函数是类方法中的一种特殊函数，当你调用它时，它会匹配派生最远的重写版本。这种特性是多态性。匹配的规则是相同的函数签名（函数名，参数个数与类型）以及返回类型（返回类型可以不相同，但必须存在派生关系）。虚函数仅需要再前面加上一个<code>virtual</code>关键字即可.</p>
<p>论是基类版本还是派生类版本，我们都在函数前面使用了<code>virtual</code>关键字，事实上，派生类中的<code>virtual</code>关键字并不是必要的。一旦基类中的方法打上了<code>virtual</code>标签，那么派生类中匹配的函数也是虚函数。但是，还是建议在后面的派生类中加上<code>virtual</code>关键字，作为虚函数的一种提醒，以便后面可能还会有更远的派生。</p>
<p>到底什么时候使用虚函数？大部分时候，我们希望派生类是真正的“重写”基类函数，而不是“隐藏”。所以一般建议将所有方法都声明为<code>virtual</code>。既然如此，为什么编译器不默认这样做呢，其实对于Java语言来说，所有的方法默认是虚函数。但是使用虚函数是有代价的，相对于普通函数，虚函数的调用代价稍高，但是这种差别不会太大，所以还是建议所有方法都使用<code>virtual</code>关键字</p>
<h4 id="析构函数要声明为虚函数"><a href="#析构函数要声明为虚函数" class="headerlink" title="析构函数要声明为虚函数"></a>析构函数要声明为虚函数</h4><p>对于析构函数，大部分时间我们只需要使用编译器提供的默认版本就好，除非涉及到释放动态分配的内存。但是如果存在继承，虚函数最好声明为虚函数。<strong>否则删除一个实际指向派生类的基类指针，只会调用基类的析构函数，而不会调用派生类的析构函数以及派生类数据成员的析构函数。</strong> 这样就可能造成内存泄露。</p>
<p><strong>参考文献</strong>:</p>
<p><a href="https://zhuanlan.zhihu.com/p/54145222">https://zhuanlan.zhihu.com/p/54145222</a></p>
]]></content>
      <categories>
        <category>c++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 队列和栈的概念、常用函数总结，方便刷题</title>
    <url>/2022/10/09/%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>解析队列与栈的概念，总结常用函数，方便LeetCode进行刷题。</p>
<span id="more"></span>
<h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><h3 id="1-1-队列"><a href="#1-1-队列" class="headerlink" title="1.1 队列"></a>1.1 队列</h3><p>队列就像是排队，向一个左通右通的容器，先进来的先出去，后进来的后出去；</p>
<h3 id="1-2-栈"><a href="#1-2-栈" class="headerlink" title="1.2 栈"></a>1.2 栈</h3><p>栈就像瓶子， 先进去的后出来，后进去的先出来</p>
<h2 id="2、常用函数"><a href="#2、常用函数" class="headerlink" title="2、常用函数"></a>2、常用函数</h2><h3 id="2-1-队列"><a href="#2-1-队列" class="headerlink" title="2.1 队列"></a>2.1 队列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue.<span class="built_in">push</span>(); <span class="comment">// 向队列的末尾加入元素</span></span><br><span class="line">queue.<span class="built_in">pop</span>();  <span class="comment">//将队列头部的元素弹出，但没有返回值</span></span><br><span class="line">queue.<span class="built_in">front</span>(); <span class="comment">//返回队列头部的元素，即最早进来的元素</span></span><br><span class="line">queue.<span class="built_in">back</span>();  <span class="comment">//返回队列尾部的元素，即最新进来的元素</span></span><br><span class="line">queue.<span class="built_in">empty</span>(); <span class="comment">//返回队列是否为空</span></span><br><span class="line">queue.<span class="built_in">size</span>();  <span class="comment">//返回队列的大小</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-栈"><a href="#2-2-栈" class="headerlink" title="2.2 栈"></a>2.2 栈</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack.<span class="built_in">push</span>(); <span class="comment">//向栈中压如元素</span></span><br><span class="line">stack.<span class="built_in">pop</span>(); <span class="comment">// 将栈中最新的元素弹出去，并且返回栈顶的元素</span></span><br><span class="line">stack.<span class="built_in">peek</span>(); <span class="comment">//返回栈顶的元素，但不弹出该元素</span></span><br><span class="line">stack.<span class="built_in">top</span>(); <span class="comment">//返回栈顶的元素</span></span><br><span class="line">stack.<span class="built_in">size</span>();<span class="comment">//返回栈内元素个数 </span></span><br><span class="line">stack.<span class="built_in">empty</span>();<span class="comment">//判断是否为空</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++常用知识</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
</search>
