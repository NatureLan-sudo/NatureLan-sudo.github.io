<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>160.相交链表</title>
    <url>/2022/09/06/160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%20%20%20%20-%20%20%20%202022-09-06/</url>
    <content><![CDATA[<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。</p>
<span id="more"></span>
<p><strong>【题目】</strong></p>
<blockquote>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209062059291.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209062059102.png"></p>
</blockquote>
<blockquote>
<p>分析：对我而言，这道问题的关键在于相交的定义。相交之后的全部节点都是相同的。因此如果存在相交，两个链表的末端应该是相等的。那么最长的情况就是，长的链表完全包含短的链表。所以我们需要对两个链表进行尾端对齐。</p>
</blockquote>
<hr>
<p>【解答】</p>
<p>1、 尾端对齐</p>
<p>时间复杂度O（m+n）,空间复杂度O（1）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 链表相交代表 相交后的节点都完全一致，最长就是完全覆盖短的链表，短的链表一直到长链表的尾部都重合。</span></span><br><span class="line">        <span class="comment">// 因此，先将链表的尾部对齐，只要是相交，尾部都是对齐的。</span></span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lenB = <span class="number">0</span>;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        <span class="comment">//获得链表A长度</span></span><br><span class="line">        <span class="keyword">while</span> (curA -&gt; next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得链表B长度</span></span><br><span class="line">        <span class="keyword">while</span> (curB -&gt; next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将curA curB置位</span></span><br><span class="line">        curB = headB;</span><br><span class="line">        curA = headA;</span><br><span class="line">        <span class="comment">//将长度更长的置为 A</span></span><br><span class="line">        <span class="keyword">while</span> (lenA &lt; lenB) &#123;</span><br><span class="line">            <span class="built_in">swap</span> (lenA, lenB);</span><br><span class="line">            <span class="built_in">swap</span> (curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n = lenA - lenB;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            curA = curA -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curA == curB) &#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA -&gt; next;</span><br><span class="line">            curB = curB -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode之链表</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>142.环形链表II</title>
    <url>/2022/09/06/142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II%20%20%20%20-%20%20%20%202022-09-06/</url>
    <content><![CDATA[<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<span id="more"></span>
<p><strong>【题目】</strong></p>
<blockquote>
<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/linked-list-cycle-ii" title="https://leetcode.cn/problems/linked-list-cycle-ii">https://leetcode.cn/problems/linked-list-cycle-ii</a></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209062058561.png"></p>
</blockquote>
<blockquote>
<p>分析：</p>
<p>主要考察两知识点：</p>
<ul>
<li><p>判断链表是否环</p>
</li>
<li><p>如果有环，如何找到这个环的入口</p>
</li>
</ul>
</blockquote>
<hr>
<p>【解答】</p>
<p>1、快慢指针 - 常规方法</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<p>分两个步骤进行</p>
<p>①利用快慢指针判断链表是否存在环</p>
<p>这个道理就是一个人一步步跑，另一个人两步两步跑，最后第二个人超越了第一个人一圈，让然后相遇了。如果说不存在环的话，那么快指针会先跑到终点，指向nullptr</p>
<p>②利用双指针判断环的入口-这里涉及到数学推导</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209062058518.png" alt="题目说明"></p>
<p>最终x &#x3D; z ；x是我们想要去求解的量，在fast指针和slow指针相遇后，让fast指针一步步走。让slow从头节点开始一步步走，重合的时候就是结点所在的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast -&gt; next !=<span class="literal">nullptr</span>) &#123; </span><br><span class="line">      <span class="comment">// 保证 fast -&gt; next ;以及 fast -&gt; next -&gt; next 存在</span></span><br><span class="line">      slow = slow -&gt; next;</span><br><span class="line">      fast = fast -&gt; next -&gt; next; <span class="comment">//由于这里向后移动了两次，为了保证不会出现空指针指向空指针</span></span><br><span class="line">      <span class="comment">//判断条件那里需要格外小心</span></span><br><span class="line">      <span class="keyword">if</span> (fast == slow) &#123;  <span class="comment">// 两个节点相遇</span></span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = slow -&gt; next;</span><br><span class="line">        fast = fast -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2、map&#x2F;unordered_map - 常规方法</p>
<p>最基本的想法，创建一个键值表，如果出现了曾经出现过的节点就可以返回了。</p>
<p>时间复杂度：底层基于红黑树的<code>map</code>，在查找某个元素的时候，采用二分查找的办法，时间为<code>O(lgn)</code>；链表n个节点，时间复杂度<code>O(nlgn)</code>. 反之，如果是无序的unordered_map，元素没有排序，所以时间复杂度为<code>O(n)</code></p>
<p>空间复杂度：创建了一个哈希表 O（n）；</p>
<p>利用map 进行实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!head) &#123; <span class="comment">//如果链表是空的直接返回NULL</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     map&lt;ListNode*, <span class="type">int</span>&gt; key;  <span class="comment">// 创建map</span></span><br><span class="line">     ListNode* pcur = head;</span><br><span class="line">     <span class="keyword">while</span> (pcur) &#123; <span class="comment">//当指针不为空的时候就进行</span></span><br><span class="line">     <span class="comment">//先判断是否出现过当前的指针，出现了就直接返回</span></span><br><span class="line">     <span class="keyword">if</span> (key.<span class="built_in">find</span>(pcur) != key.<span class="built_in">end</span>()) &#123; <span class="comment">//发现当前指针对应的并不是map的末尾，说明出现过，那就是环</span></span><br><span class="line">     <span class="keyword">return</span> pcur;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//没出现就添加到map里面</span></span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">       key[pcur] = key[pcur] + <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//指针向前移动</span></span><br><span class="line">     pcur = pcur -&gt; next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 直到遍历完了 末尾空指针跳出了循环说明没有环出现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3、野路子-非常规方法</p>
<p>时间复杂度O(n)</p>
<p>空间复杂度O(1)</p>
<p>链表是在堆上申请的空间，从低向高，如果是按顺序进行链表节点内存的申请，那么我们在环的那一点，一定存在 head → next 小于head；利用这个规律，复杂度为O（n），可以比较快速的解决问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">less</span>&lt;ListNode*&gt;()(head,head-&gt;next)) <span class="comment">// !(head地址小于head -&gt; next)</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">return</span> head -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head -&gt; next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode之链表</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>19.删除链表的倒数第N个元素</title>
    <url>/2022/09/04/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E5%85%83%E7%B4%A0%20%20%20%20-%20%20%20%202022-09-04/</url>
    <content><![CDATA[<p>给你一个链表，删除链表的倒数第N个结点并返回链链表的头结点。利用双指针中的快慢指针解决问题。</p>
<span id="more"></span>
<p><strong>【题目】</strong></p>
<blockquote>
<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209041513536.png"></p>
</blockquote>
<blockquote>
<p><strong>分析：</strong></p>
<p>对于链表而言，访问特定下标的元素是很困难的。</p>
<p>我们做过三个相关的题目：</p>
<p>1、设计链表：在特定的位置插入元素，特定的正向位置删除元素，这需要我们从虚拟头结点开始进行遍历。</p>
<p>2、删除链表的中间节点：这时候我们并不知道应该删除的是哪一个下标，我们通过遍历得到链表的长度也不是现实的，所以我们可以选择利用指针移动之间的倍数关系来实现。即：双指针中的快慢指针，快指针一次走两个格，慢指针一次走一个格，当快指针走到头的时候，慢指针刚好走到了中央的位置。</p>
<p>3、就是我们要删除倒数的元素了，我们可以让快的节点超过慢节点n个元素，当快节点到头的时候，慢节点刚好指向了倒数第n个元素。但需要注意的是，我们希望进行删除操作，所以我们需要在操作第N个元素的前一个节点，所以，判断关系很重要。</p>
</blockquote>
<hr>
<p>【解答】</p>
<p>双指针-快慢双指针法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        prev -&gt; next = head;</span><br><span class="line">        ListNode* slow = prev;</span><br><span class="line">        ListNode* fast = prev;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            fast = fast -&gt; next;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> prev -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast -&gt; next != <span class="literal">nullptr</span>) &#123; <span class="comment">// 要删掉的节点的前一个节点</span></span><br><span class="line">            fast = fast -&gt; next;</span><br><span class="line">            slow = slow -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow -&gt; next = slow -&gt; next -&gt; next;</span><br><span class="line">        <span class="keyword">return</span> prev -&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode之链表</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>三星 C++ 怎么防止内存泄漏</title>
    <url>/2022/09/13/%E4%B8%89%E6%98%9F%20%E6%80%8E%E4%B9%88%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F%20%20%20%20-%20%20%20%202022-09-05/</url>
    <content><![CDATA[<p>内存泄漏将会导致系统内存中无用的空间越来越多，最终导致内存不足，内存爆炸。所以，有必要防止内存泄漏。本文介绍了两种防止内存泄漏的方法以及内存泄漏检测工具valgrind的实现原理。</p>
<span id="more"></span>
<h2 id="1、防止内存泄漏"><a href="#1、防止内存泄漏" class="headerlink" title="1、防止内存泄漏"></a>1、防止内存泄漏</h2><h3 id="1、内部封装"><a href="#1、内部封装" class="headerlink" title="1、内部封装"></a>1、内部封装</h3><p>将内存的分配和释放封装到类中。在类中构造构造函数和析构函数。构造的时候分配内存空间，最后从析构函数中释放内存空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span> p*;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> p_size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">unsigned</span> <span class="type">int</span> n = <span class="number">1</span>) &#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">char</span>[n]; <span class="comment">// 构造函数分配内存</span></span><br><span class="line">    p_size = n;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">A</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="keyword">delete</span>[] p; <span class="comment">// 删除字符数组的内存空间，在堆上</span></span><br><span class="line">     p = <span class="literal">NULL</span>;  <span class="comment">// p指向的空间已经被删除了，给p重新赋值，避免出现野指针。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该方法不是最佳的做法，因为在类的对象复制时，程序会出现同一块内存空间释放两次的情况。</p>
<p>在一个函数内创建两个类的对象，让一个对象等于另一个对象。在离开函数作用域的时候，将会调用两次析构函数来释放空间，但是两个对象指向同一块内存，所以同一块内存就被释放了两次。** 可以通过增加计数机制来避免这种情况**；</p>
<h3 id="2、智能指针"><a href="#2、智能指针" class="headerlink" title="2、智能指针"></a>2、智能指针</h3><p>智能指针是 C++ 中已经对内存泄漏封装好了一个工具，可以直接拿来使用。可以自己计数。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209132043830.png"></p>
<p><img data-src="/image/image_VK2HHXZfof.png"></p>
]]></content>
      <categories>
        <category>c++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>五星 C++ 堆和栈的区别</title>
    <url>/2022/09/02/%E4%BA%94%E6%98%9F%20C++%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E5%8C%BA%E5%88%AB%20%20%20-%20%20%20%202022-08-29/</url>
    <content><![CDATA[<p><strong>申请方式：</strong> 栈是系统自动分配，堆是程序员主动申请。<strong>申请后系统响应：</strong>分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。<br>栈在内存中是连续的一块空间（向低地址扩展）<strong>最大容量是系统预定好的</strong>，堆在内存中的空间（向高地址扩展）是<strong>不连续</strong>的。<br><strong>申请效率：</strong> 栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。<br><strong>存放的内容：</strong> 栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。</p>
<span id="more"></span>

<p><strong>问题1：堆的内存为什么是不连续的</strong></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209021418598.png"></p>
<p><strong>问题2：堆和栈的不同点</strong></p>
<p>管理方式：堆-程序员。栈-系统。</p>
<p>空间大小：堆-不确定。栈-最大容量是系统设定好的。</p>
<p>生长方向：堆-向高地址扩展，不连续。栈-向低地址扩展，连续。</p>
<p>分配效率：堆-程序员申请，效率低，容易产生碎片。栈-系统分配，效率高，但是程序员不能控制。</p>
<p>存放内容：堆-程序员自己申请的内容。栈-局部变量，函数参数等。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209021418580.png"></p>
]]></content>
      <categories>
        <category>C++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>五星 C++ 内存管理</title>
    <url>/2022/09/01/%E4%BA%94%E6%98%9FC++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20-2022-08-29/</url>
    <content><![CDATA[<p>C++ 内存分区：<strong>栈、堆、全局&#x2F;静态存储区、常量存储区、代码区</strong>。</p>
<span id="more"></span>

<p><strong>栈</strong>：存放函数的局部变量、函数参数、返回地址等，<strong>由编译器自动分配和释放</strong>。</p>
<blockquote>
<p>栈是线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，就是切换SS&#x2F;ESP寄存器。栈空间不需要在高级语言里面显式的分配和释放。</p>
</blockquote>
<p><strong>堆</strong>：动态申请的内存空间，就是由 **malloc **分配的内存块，<strong>由程序员控制它的分配和释放</strong>，如果程序执行结束还没有释放，操作系统会自动回收。（是可能会会释放，所以说，用完了一定记得要释放，不然会造成内存泄露）。</p>
<blockquote>
<p>堆一般由程序员分配释放，若不释放，程序结束时可能由OS回收。注意这里说是可能，并非一定。所以我想再强调一次，记得要释放！注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</p>
<p>当内存不再使用的时候，应使用free()函数将内存块释放掉。</p>
</blockquote>
<p><strong>全局区&#x2F;静态存储区（.bss 段和 .data 段）</strong>：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。</p>
<blockquote>
<p>解释一下静态变量</p>
<p>静态变量通过关键字static进行声明。</p>
<p>经static修饰过后的变量或者函数的作用域会发生变化。该变量存储在数据段上，可以改变变量的作用域和生命周期。</p>
<p><strong>全局静态变量</strong></p>
<p>在全局变量前面加上关键词static，全局变量就被定义成一个全局静态变量</p>
<p>（1）内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）</p>
<p>（2）初始化：未经初始化的全局静态变量会被程序自动初始化为0</p>
<p>（3）作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。</p>
<p><strong>局部静态变量</strong></p>
<p>在局部变量前面加上关键词static，局部变量就被定义成一个局部静态变量。</p>
<p>（1）内存中的位置：静态存储区</p>
<p>（2）初始化：未经初始化的局部静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）</p>
<p>（3）作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。</p>
<p><strong>C语言中使用静态函数的好处</strong></p>
<p>（1）静态函数会被自动分配在一个一直使用的存储区，直到退出程序，<strong>避免了调用函数的压栈出栈</strong>，速度快很多。</p>
<p>（2）static指函数的作用域仅局限于本文件。不<strong>用担心自己定义的函数是否会与其他文件的函数同名</strong></p>
</blockquote>
<p><strong>常量存储区（.data 段）</strong>：存放的是<strong>常量，不允许修改</strong>，程序运行结束自动释放。<br><strong>代码区（.text 段）</strong>：<strong>存放代码，不允许修改</strong>，但可以执行。编译后的二进制文件存放在这里。<br>说明：</p>
<p>从操作系统的本身来讲，以上存储区在内存中的分布是如下形式(从低地址到高地址)：</p>
<p><strong>.text 段 –&gt; .data 段 –&gt; .bss 段 –&gt; 堆 –&gt; unused –&gt; 栈 –&gt; env</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明：C++ 中不再区分初始化和未初始化的全局变量、静态变量的存储区，如果非要区分下述程序标注在了括号中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_var = <span class="number">0</span>; <span class="comment">// g_var 在全局区（.data 段）</span></span><br><span class="line"><span class="type">char</span> *gp_var;  <span class="comment">// gp_var 在全局区（.bss 段）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> var;                    <span class="comment">// var 在栈区</span></span><br><span class="line">    <span class="type">char</span> *p_var;                <span class="comment">// p_var 在栈区</span></span><br><span class="line">    <span class="type">char</span> arr[] = <span class="string">&quot;abc&quot;</span>;         <span class="comment">// arr 为数组变量，存储在栈区；&quot;abc&quot;为字符串常量，存储在常量区</span></span><br><span class="line">    <span class="type">char</span> *p_var1 = <span class="string">&quot;123456&quot;</span>;    <span class="comment">// p_var1 在栈区；&quot;123456&quot;为字符串常量，存储在常量区</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_var = <span class="number">0</span>;       <span class="comment">// s_var 为静态变量，存在静态存储区（.data 段）</span></span><br><span class="line">    p_var = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>); <span class="comment">// 分配得来的 10 个字节的区域在堆区</span></span><br><span class="line">    <span class="built_in">free</span>(p_var);                <span class="comment">// 因为使用了malloc堆的空间，由程序员自己释放掉</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：力扣 (LeetCode)</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/leetbook/read/cpp-interview-highlights/e4vkxv/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>五星 C++ 智能指针的分类、实现原理、易出现的问题</title>
    <url>/2022/09/13/%E4%BA%94%E6%98%9F%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%88%86%E7%B1%BB%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E3%80%81%E6%98%93%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%20%20%20-%20%20%20%202022-09-05/</url>
    <content><![CDATA[<p>智能指针是高频考察内容；本文讲述了智能指针的分类，实现原理以及容易出现的问题及其解决方式。</p>
<p>智能指针是为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的。C++11 中封装在了 <code>&lt;memory&gt;</code> 头文件中。</p>
<span id="more"></span>

<p>C++11 中智能指针包括以下三种：</p>
<ul>
<li><p><strong>共享指针（shared_ptr）</strong>：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过 <code>use_count()</code> 查看资源的所有者的个数，可以通过 <code>unique_ptr</code>、<code>weak_ptr</code> 来构造，调用 <code>release()</code> 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。</p>
</li>
<li><p><strong>独占指针（unique_ptr）</strong>：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用 <code>move()</code> 函数），即一个 <code>unique_ptr</code> 对象赋值给另一个 <code>unique_ptr</code> 对象，可以通过该方法进行赋值。</p>
</li>
<li><p><strong>弱指针（weak_ptr）</strong>：指向 <code>share_ptr</code> 指向的对象，能够解决由shared_ptr带来的循环引用问题。</p>
</li>
</ul>
<p>智能指针的实现原理是计数原理。</p>
<blockquote>
<p>在C++中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针（smart pointer）。智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。</p>
</blockquote>
<h2 id="1、共享指针（shared-ptr）"><a href="#1、共享指针（shared-ptr）" class="headerlink" title="1、共享指针（shared_ptr）"></a>1、共享指针（shared_ptr）</h2><h3 id="1、初始化"><a href="#1、初始化" class="headerlink" title="1、初始化"></a>1、初始化</h3><blockquote>
<p>共享智能指针是指多个智能指针可以同时管理同一块有效的内存，共享智能指针shared_ptr 是一个模板类，如果要进行初始化有三种方式：通过构造函数、std::make_shared辅助函数以及reset方法。共享智能指针对象初始化完毕之后就指向了要管理的那块堆内存，如果想要查看当前有多少个智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数use_count。<strong>如果我们不初始化一个智能指针，他会被初始化为一个空指针 。</strong></p>
</blockquote>
<h3 id="2、获得原始地址"><a href="#2、获得原始地址" class="headerlink" title="2、获得原始地址"></a>2、获得原始地址</h3><blockquote>
<p>利用get()获得原地址；对应基础数据类型来说，通过操作智能指针和操作智能指针管理的内存效果是一样的，可以直接完成数据的读写。但是如果共享智能指针管理的是一个对象，那么就需要取出原始内存的地址再操作，可以调用共享智能指针类提供的get()方法得到原始地址</p>
</blockquote>
<h3 id="3、指定删除器"><a href="#3、指定删除器" class="headerlink" title="3、指定删除器"></a>3、指定删除器</h3><blockquote>
<p>当智能指针管理的内存对应的引用计数变为0的时候，这块内存就会被智能指针析构掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为删除器，这个删除器函数本质是一个回调函数，我们只需要进行实现，其调用是由智能指针完成的。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">m_num</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> x) : <span class="built_in">m_num</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test, x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Test</span>(string str) : <span class="built_in">m_num</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destruct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_num = v;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m_num: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*--------------------------  一，初始化智能指针shared_ptr  ------------------------------*/</span></span><br><span class="line">    <span class="comment">//1.通过构造函数初始化</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">3</span>))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//2.通过移动和拷贝构造函数初始化</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3 = ptr2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//3.通过 std::make_shared初始化 这种初始化方法是最好的</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr4 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">8</span>);</span><br><span class="line">    shared_ptr&lt;Test&gt; ptr5 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="number">7</span>);</span><br><span class="line">    shared_ptr&lt;Test&gt; ptr6 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="string">&quot;GOOD LUCKLY!&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//4.通过reset初始化</span></span><br><span class="line">    ptr6.<span class="built_in">reset</span>(); <span class="comment">//重置ptr6, ptr6的引用基数为0</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr6管理的内存引用计数: &quot;</span> &lt;&lt; ptr6.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    ptr5.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr5管理的内存引用计数: &quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*--------------------------  二，共享智能指针shared_ptr的使用  ------------------------------*/</span></span><br><span class="line">    <span class="comment">//1.方法一</span></span><br><span class="line">    Test* t = ptr5.<span class="built_in">get</span>();</span><br><span class="line">    t-&gt;<span class="built_in">setValue</span>(<span class="number">1000</span>);</span><br><span class="line">    t-&gt;<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//2.方法二</span></span><br><span class="line">    ptr5-&gt;<span class="built_in">setValue</span>(<span class="number">7777</span>);</span><br><span class="line">    ptr5-&gt;<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">    <span class="comment">/*------------------------------------  三，指定删除器  -----------------------------------*/</span></span><br><span class="line">     <span class="comment">//1.简单举例</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">ppp</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">100</span>), [](Test* t) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">//释放内存</span></span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;Test对象的内存被释放了.......&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">delete</span> t;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="number">2.</span>如果是数组类型的地址，就需要自己写指定删除器，否则内存无法全部释放</span><br><span class="line">    <span class="comment">//shared_ptr&lt;Test&gt; p1(new Test[5], [](Test* t) &#123;</span></span><br><span class="line">    <span class="comment">//    delete[]t;</span></span><br><span class="line">    <span class="comment">//    &#125;);</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//3.也可以使用c++给我们提供的 默认删除器函数（函数模板）</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">3</span>], default_delete&lt;Test[]&gt;())</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//4.c++11以后可以这样写 也可以自动释放内存</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Test[]&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">3</span>])</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外，我们还可以自己封装一个函数模板make_shared_array方法来让shared_ptr支持数组，代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//有了这个函数模板，我们就不用自己去释放数组类型的地址了</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">make_share_array</span><span class="params">(<span class="type">size_t</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//返回匿名对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T[size], <span class="built_in">default_delete</span>&lt;T[]&gt;());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_share_array</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">  cout &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">  shared_ptr&lt;string&gt; ptr2 = <span class="built_in">make_share_array</span>&lt;string&gt;(<span class="number">7</span>);</span><br><span class="line">  cout &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最安全的分配和使用动态内存的方法是调用make_shared标准库函数。此函数在动态内存中分配一个对象并从初始化它，返回指向此对象的shared_ptr。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt; (<span class="number">42</span>);</span><br><span class="line"><span class="comment">//要指定类型和初始化的内容，指向一个值为42的int类型的智能指针。</span></span><br></pre></td></tr></table></figure>

<p>我们不能将一个内置指针转换为一个智能指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>);<span class="comment">//这种是错误的</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">100</span>))</span></span>; <span class="comment">//这种是正确的</span></span><br></pre></td></tr></table></figure>

<h2 id="2、独占指针-unique-ptr"><a href="#2、独占指针-unique-ptr" class="headerlink" title="2、独占指针 (unique_ptr)"></a>2、独占指针 (unique_ptr)</h2><h3 id="1、初始化-1"><a href="#1、初始化-1" class="headerlink" title="1、初始化"></a>1、初始化</h3><blockquote>
<p>std::unique_ptr是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针，可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个unique_ptr赋值给另一个unique_ptr。不过我们可以通过move函数，将一个独占指针的值赋给另一个独占指针。</p>
</blockquote>
<p>独占指针的初始化必须采用直接初始化方式，不支持拷贝，也不支持赋值。</p>
<p>正确的初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; ptr;</span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">55</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p>错误的初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(ptr1)</span></span>; <span class="comment">//错误，不支持拷贝</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; ptr = ptr1; <span class="comment">// 错误，不支持赋值。</span></span><br></pre></td></tr></table></figure>

<h3 id="2、删除器"><a href="#2、删除器" class="headerlink" title="2、删除器"></a>2、删除器</h3><p>问题：如何将一个unique_ptr赋值给另一个unique_ptr?</p>
<p>A：可以利用std::move，其目的是实现所有权的转移。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A 作为一个类 </span></span><br><span class="line"><span class="function">std::unique_ptr&lt;A&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">std::unique_ptr&lt;A&gt; ptr2 = std::<span class="built_in">move</span>(ptr1);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">m_num</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> x) : <span class="built_in">m_num</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test, x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Test</span>(string str) : <span class="built_in">m_num</span>(<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destruct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_num = v;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m_num: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*--------------------------  一，初始化智能指针unique_ptr  ------------------------------*/</span></span><br><span class="line">    <span class="comment">//1.通过构造函数初始化</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">3</span>))</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//2.通过移动函数初始化</span></span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//.通过reset初始化</span></span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">7</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*--------------------------  二，unique_ptr的使用  ------------------------------*/</span></span><br><span class="line">    <span class="comment">//1.方法一</span></span><br><span class="line">    <span class="function">unique_ptr&lt;Test&gt; <span class="title">ptr3</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">666</span>))</span></span>;</span><br><span class="line">    Test* pt = ptr3.<span class="built_in">get</span>();</span><br><span class="line">    pt-&gt;<span class="built_in">setValue</span>(<span class="number">6</span>);</span><br><span class="line">    pt-&gt;<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//2.方法二</span></span><br><span class="line">    ptr3-&gt;<span class="built_in">setValue</span>(<span class="number">777</span>);</span><br><span class="line">    ptr3-&gt;<span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*------------------------------------  三，指定删除器  -----------------------------------*/</span></span><br><span class="line">    <span class="comment">//1.函数指针类型</span></span><br><span class="line">    <span class="comment">//using ptrFunc = void(*)(Test*);</span></span><br><span class="line">    <span class="comment">//unique_ptr&lt;Test, ptrFunc&gt; ptr4(new Test(&quot;hello&quot;), [](Test* t) &#123;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//    delete t;</span></span><br><span class="line">    <span class="comment">//    &#125;);</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//2.仿函数类型（利用可调用对象包装器）</span></span><br><span class="line">    unique_ptr&lt;Test, function&lt;<span class="type">void</span>(Test*)&gt;&gt; <span class="built_in">ptr4</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="string">&quot;hello&quot;</span>), [](Test* t) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> t;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*---------- 四，独占(共享)的智能指针可以管理数组类型的地址，能够自动释放 ---------*/</span></span><br><span class="line">    <span class="function">unique_ptr&lt;Test[]&gt; <span class="title">ptr5</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">3</span>])</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在c++11中shared_ptr不支持下面的写法，c++11以后才支持的</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Test[]&gt; <span class="title">ptr6</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">3</span>])</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、弱指针-weak-ptr"><a href="#3、弱指针-weak-ptr" class="headerlink" title="3、弱指针 (weak_ptr)"></a>3、弱指针 (weak_ptr)</h2><p>弱引用智能指针std::weak_ptr可以看做是shared_ptr的助手，它不管理shared_ptr内部的指针。std::weak_ptr没有重载操作符*和-&gt;，因为它不共享指针，不能操作资源，所以它的构造不会增加引用计数，析构也不会减少引用计数，它的主要作用就是作为一个旁观者监视shared_ptr中管理的资源是否存在。</p>
<h3 id="1、初始化-2"><a href="#1、初始化-2" class="headerlink" title="1、初始化"></a>1、初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp1;</span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp2</span><span class="params">(wp1)</span></span>;</span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp3</span><span class="params">(sp)</span></span>;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp4;</span><br><span class="line">    wp4 = sp;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp5;</span><br><span class="line">    wp5 = wp3;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>weak_ptr&lt;int&gt; wp1;构造了一个空weak_ptr对象</p>
<p>weak_ptr&lt;int&gt; wp2(wp1);通过一个空weak_ptr对象构造了另一个空weak_ptr对象</p>
<p>weak_ptr&lt;int&gt; wp3(sp);通过一个shared_ptr对象构造了一个可用的weak_ptr实例对象</p>
<p>wp4 &#x3D; sp;通过一个shared_ptr对象构造了一个可用的weak_ptr实例对象（这是一个隐式类型转换）</p>
<p>wp5 &#x3D; wp3;通过一个weak_ptr对象构造了一个可用的weak_ptr实例对象</p>
<p>通过调用std::weak_ptr类提供的use_count()方法可以获得当前所观测资源的引用计数</p>
<h3 id="2、常用函数"><a href="#2、常用函数" class="headerlink" title="2、常用函数"></a>2、常用函数</h3><p>通过调用std::weak_ptr类提供的expired()方法来判断观测的资源是否已经被释放</p>
<p>通过调用std::weak_ptr类提供的lock()方法来获取管理所监测资源的shared_ptr对象</p>
<p>通过调用std::weak_ptr类提供的reset()方法来清空对象，使其不监测任何资源</p>
<ul>
<li>利用**<code>weak_ptr可以解决shared_ptr的一些问题</code>**</li>
</ul>
<ol>
<li>返回管理this的shared_ptr</li>
</ol>
<p>&amp;#x20;2.  解决循环引用问题</p>
<h2 id="4、使用是智能指针会出现什么问题？"><a href="#4、使用是智能指针会出现什么问题？" class="headerlink" title="4、使用是智能指针会出现什么问题？"></a>4、使用是智能指针会出现什么问题？</h2><p>循环引用；</p>
<p>两个类内的循环指针互相指向，没有指向环中的外部共享指针，<code>shared_ptr</code> 引用计数无法抵达 0，该调用析构函数但是没能调用，导致了内存泄漏。</p>
<p>使用弱指针，可以避免这个问题：</p>
<ul>
<li><p><code>weak_ptr</code>对被<code>shared_ptr</code>管理的对象存在<strong>非拥有性引用</strong>，在访问所引用的对象前必须先转化为<code>shared_ptr</code>；</p>
</li>
<li><p><code>weak_ptr</code>用来打断<code>shared_ptr</code>所管理对象的循环引用问题，若这种环被孤立（没有指向环中的外部共享指针），<code>shared_ptr</code>引用计数无法抵达0，内存被泄露；令环中的指针之一为弱指针可以避免该情况。</p>
</li>
<li><p><code>weak_ptr</code>用来表示临时所有权的概念。当某个对象只有存在时才需要被访问，而且随时可能被他人删除，可以用<code>weak_ptr</code>跟踪该对象；需要获得所有权时将其转化为<code>shared_ptr</code>，此时如果原来的<code>shared_ptr</code>被销毁，则该对象的生命周期被延长到这个临时的<code>shared_ptr</code>同样被销毁。</p>
</li>
</ul>
<p>未使用弱指针：</p>
<p>起初定义完<code>ptr_a</code>和<code>ptr_b</code>时，只有1，3两条引用，即<code>ptr_a</code>指向CA对象，<code>ptr_b</code>指向CB对象。然后调用函数<code>set_ptr()</code>后又增加了2，4两条引用，即CB对象中的<code>m_ptr_a</code>成员变量指向CA对象，CA对象中的<code>m_ptr_b</code>成员变量指向CB对象。</p>
<p>这个时候，指向CA对象的有两个，指向CB对象的也有两个。当main函数运行结束时，对象<code>ptr_a</code>和<code>ptr_b</code>被销毁，也就是1，3两条引用会被断开，2，4两条引用依然存在，每一个的引用计数都不为0，结果就导致其指向的内部对象无法析构，造成内存泄漏。</p>
<p>2，4之间的引用，m_ptr_a指向CA，CA不为空，m_ptr_a有效，不能被释放掉。同时由于m_ptr_a的存在，CB不为空，m_ptr_b不能被释放掉。这就导致了这两个相互引用的次数一直为1，不能被释放，计数机制失效了，造成了内存泄漏。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209132044091.png"></p>
<p>使用弱指针：</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209132044244.png"></p>
<p>流程与上一例子大体相似，但是不同的是4这条引用是通过<code>weak_ptr</code>建立的，并不会增加引用计数。也就是说，CA的对象只有一个引用计数，而CB的对象只有两个引用计数，当main函数返回时，对象<code>ptr_a</code>和<code>ptr_b</code>被销毁，也就是1，3两条引用会被断开，此时CA对象的引用计数会减为0，对象被销毁，进而解决了引用成环的问题。</p>
<h2 id="5、使用new和delete管理动态内存的缺点（坚持使用智能指针）"><a href="#5、使用new和delete管理动态内存的缺点（坚持使用智能指针）" class="headerlink" title="5、使用new和delete管理动态内存的缺点（坚持使用智能指针）"></a>5、使用new和delete管理动态内存的缺点（坚持使用智能指针）</h2><p>使用new和delete管理动态内存容易存在问题：</p>
<p>1、忘记用delete 释放内存</p>
<p>2、同一块内存由于拷贝，可能被释放了两次</p>
<p>3、可能会使用释放后的对象</p>
<p>因此，坚持使用智能指针，可以避免所有这些问题，对于一块内存，只有在没有任何指针指向的时候，才会释放他。</p>
]]></content>
      <categories>
        <category>c++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>四星 C++ 程序编译过程</title>
    <url>/2022/08/31/%E5%9B%9B%E6%98%9FC++%20%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%20-%202022-08-28/</url>
    <content><![CDATA[<p>编译过程可以分为以下三个过程：编译（编译预处理、编译、优化），汇编，链接。<br>其中编译又可以分为编译预处理以及编译优化，就可以划分为四部分。</p>
<span id="more"></span>

<h2 id="1、编译预处理"><a href="#1、编译预处理" class="headerlink" title="1、编译预处理"></a>1、编译预处理</h2><p>编译预处理：处理以 # 开头的指令；</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SOMEFILE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOMEFILE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta">#program once</span></span><br></pre></td></tr></table></figure>

<h2 id="2、编译、优化"><a href="#2、编译、优化" class="headerlink" title="2、编译、优化"></a>2、编译、优化</h2><p>将源码 .cpp 文件翻译成 .s 汇编代码；</p>
<h2 id="3、汇编"><a href="#3、汇编" class="headerlink" title="3、汇编"></a>3、汇编</h2><p>将汇编代码 .s 翻译成机器指令 .o 文件；</p>
<h2 id="4、链接"><a href="#4、链接" class="headerlink" title="4、链接"></a>4、链接</h2><p>汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。</p>
<p><strong>链接包括静态链接和动态链接</strong></p>
<p><strong>静态链接</strong>：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</p>
<p>通俗的讲：静态链接将程序调用的库一起打包到可执行文件中，这样执行时候就不用调用其他的库，速度快。但是，可能多个文件都链接了同一个库，那么这个库就被打包了很多次，造成了该空间上的浪费。如果这个库更新了的话，整个程序需要重新编译。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208302038882.png" alt="静态链接"></p>
<p><strong>动态链接</strong>：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</p>
<p>通俗的讲：动态链接是在程序执行时候才引入的库，因此方便更新。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208302038200.png" alt="动态链接"></p>
<p>二者的优缺点：</p>
<p>静态链接：<strong>浪费空间，</strong>每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序<strong>（更新困难）</strong>；优点就是执行的时候运行<strong>速度快，</strong> 因为可执行程序具备了程序运行的所有内容。<br>动态链接：<strong>节省内存、更新方便</strong>，但是动态链接是在程序运行时，每次执行都需要链接，<strong>相比静态链接会有一定的性能损失。</strong></p>
]]></content>
      <categories>
        <category>C++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>四星 C++ 变量的区别</title>
    <url>/2022/09/04/%E5%9B%9B%E6%98%9F%20C++%20%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB-2022-08-30/</url>
    <content><![CDATA[<p>全局变量、局部变量、静态全局变量、静态局部变量的区别<br>C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。</p>
<span id="more"></span>
<p>从作用域看：</p>
<p><strong>全局变量：</strong> 具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量。</p>
<p><strong>静态全局变量：</strong>具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，<strong>它作用于定义它的文件里，不能作用到其它文件里</strong>，即被 static 关键字修饰过的变量具有文件作用域。这样即使<strong>两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</strong></p>
<p><strong>局部变量：</strong>具有局部作用域。它是自动对象（auto），在程序运行期间<strong>不是一直存在</strong>，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。</p>
<p><strong>静态局部变量：</strong>具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都<strong>一直存在</strong>，<strong>它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。</strong><br>从分配内存空间看：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于数据来说，声明和定义往往是同时存在的，比如下面的一行语句,既定义也声明了。</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//只声明不定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> data;</span><br><span class="line"><span class="comment">//对于函数来说，函数声明一般写在头文件中，函数的定义一般写在源文件中；</span></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">helloworld</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">helloworld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用变量之前必须声明，声明可以有多次，而定义只能有一次。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>静态存储区：</strong> 全局变量，静态局部变量，静态全局变量。<br><strong>栈：</strong> 局部变量。</p>
<p>静态变量和栈变量（存储在栈中的变量）、堆变量（存储在堆中的变量）的区别：<strong>静态变量会被放在程序的静态数据存储区（.data 段）中（静态变量会自动初始化），这样可以在下一次调用的时候还可以保持原来的赋值。</strong> 而栈变量或堆变量不能保证在下一次调用的时候依然保持原来的值。</p>
<p>静态变量是通过区分存放位置来保证其特殊的生命周期的。栈变量程序会自动释放。堆变量要由程序员自己释放。<br>静态变量和全局变量的区别：静态变量用 static 告知编译器，<strong>自己仅仅在变量的作用范围内可见</strong></p>
<blockquote>
<p>对于静态全局变量，只在该文件中生效，在其他文件中不生效，因此，在其他文件中，可以定义同名的静态全局变量。</p>
<p>对于静态局部变量，在局部函数体中，只要被初始化，就会一直存在，不会被释放。</p>
<p>全局变量，定义后，在其他文件中声明，就可以使用，不能存在同名的定义。并不需要引用头文件文件，但是依然可以在不同文件间共享变量和函数，这一切都是extern的功劳！</p>
</blockquote>
<p>××××</p>
<p>**全局变量定义在头文件中会出现什么问题 **</p>
<blockquote>
<p>如果在头文件中定义全局变量，当该头文件被多个文件 <code>include</code> 时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能再头文件中定义全局变量。</p>
</blockquote>
<p>include一个头文件，相当于把他带包写到了另一个文件，就会被多次定义。</p>
<p><strong>所以全局变量应该被定义在源文件中。</strong> 其他程序使用，利用extern进行声明。</p>
]]></content>
      <categories>
        <category>C++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>四星 C++ 内存泄漏</title>
    <url>/2022/09/13/%E5%9B%9B%E6%98%9F%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%20%20%20%20-%20%20%20%202022-09-01/</url>
    <content><![CDATA[<p><strong>内存泄漏：由于疏忽或错误导致的程序未能释放已经不再使用的内存。</strong><br>进一步解释：</p>
<ul>
<li><p>并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。</p>
</li>
<li><p><strong>常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。</strong></p>
</li>
<li><p>使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete 释放内存，否则这块内存就会造成内存泄漏。</p>
</li>
<li><p>指针重新赋值</p>
<span id="more"></span></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">char</span> *p1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">p = np;</span><br></pre></td></tr></table></figure>

<p>开始时，指针 p 和 p1 分别指向一块内存空间，但指针 p 被重新赋值，导致 p 初始时指向的那块内存空间无法找到，从而发生了内存泄漏。</p>
<p>忘记了释放内存，造成内存泄露的后果</p>
<blockquote>
<p>含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。</p>
</blockquote>
<p><strong>再提一嘴内存溢出</strong></p>
<p>概念：内存溢出out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请一个int，但是给其存了long才能存得下的数，那就是内存溢出</p>
<blockquote>
<p>发生原因</p>
<ul>
<li><p>内存中加载的数据量过于庞大；</p>
</li>
<li><p>代码中存在<strong>死循环</strong>；</p>
</li>
<li><p>递归调用<strong>太深，导致栈溢出</strong>；</p>
</li>
<li><p><strong>内存泄漏</strong>最终导致内存溢出。</p>
</li>
</ul>
</blockquote>
<p><strong>再来一嘴野指针</strong></p>
<p>指向已经删除的对象或者申请访问受限内存区域的指针，称为野指针。</p>
<p>野指针与空指针不同，空指针是null。但是野指针并不知道指向了哪里，只能通过编程习惯规避。</p>
<blockquote>
<p>可能发生的原因：</p>
<ul>
<li><p>指针没有初始化：指针变量在被创建未初始化时，并不是空指针，它的缺省值是随机的，会乱指一气。所以指针变量在创建同时就应对其进行初始化，要么将指针设置为NULL，要么让其指向一个合法的内存。</p>
</li>
<li><p>指针释放之后未置空：有时指针在free或者delete之后未赋值NULL，有可能被误以为是合法的指针，不能进关注free和delete后的指针名，他们只是将指针所指向的内存空间释放掉而已，但并没有把指针自身消灭，此时，指针指向的就是“垃圾”内存。被释放掉内存空间的指针应该立即将其置为NULL，防止产生野指针。</p>
</li>
<li><p>指针操作超越变量作用域</p>
</li>
</ul>
<p>我觉得重点还是关注 没有初始化，以及本来指向了一块内存，然后指向的变量生命周期结束了，这个指针没有指向了，要及时置空。</p>
</blockquote>
]]></content>
      <categories>
        <category>c++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>三星 C++ 在堆-栈上建立对象</title>
    <url>/2022/09/13/%E5%9C%A8%E5%A0%86-%20%E6%A0%88%E5%BB%BA%E7%AB%8B%E5%AF%B9%E8%B1%A1%20%20%20%20-%20%20%20%202022-08-31/</url>
    <content><![CDATA[<p>**如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？<br>**说明：C++ 中的类的对象的建立分为两种：<strong>静态建立、动态建立。</strong></p>
<p><strong>静态建立：</strong> 由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象。例如：A a;<br><strong>动态建立：</strong> 使用 new 关键字在堆空间上创建对象，底层首先调用 operator new() 函数，在堆空间上寻找合适的内存并分配；然后，调用类的构造函数创建对象。例如：A *p &#x3D; new A();</p>
<span id="more"></span>
<h2 id="1、类的构造函数"><a href="#1、类的构造函数" class="headerlink" title="1、类的构造函数"></a>1、类的构造函数</h2><blockquote>
<p>类的<strong>构造函数</strong>是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。</p>
<p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。</p>
<p>默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(); <span class="comment">//无参数的构造函数</span></span><br><span class="line"> <span class="comment">// A(int line); //有参数的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2、类的析构函数"><a href="#2、类的析构函数" class="headerlink" title="2、类的析构函数"></a>2、类的析构函数</h2><blockquote>
<p>类的<strong>析构函数</strong>是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。</p>
<p>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，<strong>它不会返回任何值，也不能带有任何参数。</strong> 析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(); <span class="comment">// 构造函数声明</span></span><br><span class="line">  ~<span class="built_in">A</span>(); <span class="comment">//析构函数声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3、限制对象建立在堆上"><a href="#3、限制对象建立在堆上" class="headerlink" title="3、限制对象建立在堆上"></a>3、限制对象建立在堆上</h2><p><strong>在栈上创建的必要条件是，构造函数和析构函数必须有外部访问权限。</strong></p>
<p>限制对象只能建立在堆上：</p>
<p>最直观的思想：避免直接调用类的构造函数，因为对象静态建立时，会调用类的构造函数创建对象。但是直接将类的构造函数设为私有并不可行，因为当构造函数设置为私有后，不能在类的外部调用构造函数来构造对象，只能用 new 来建立对象。但是由于 new 创建对象时，底层也会调用类的构造函数，将构造函数设置为私有后，那就无法在类的外部使用 new 创建对象了。因此，这种方法不可行。</p>
<p><strong>解决方法 1：</strong></p>
<p>将析构函数设置为私有。原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性。当析构函数设为私有时，编译器创建的对象就<strong>无法通过访问析构函数来释放对象的内存空间</strong>，因此，编译器不会在栈上为对象分配内存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destory</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>该方法存在的问题：</p>
<p>用 new 创建的对象，通常会使用 delete 释放该对象的内存空间，<strong>但此时类的外部无法调用析构函数</strong>(因为我们已经把析构函数设置为私有啦，所以我们需要自己写一个成员函数，来释放内存)，因此类内必须定义一个 destory() 函数，用来释放 new 创建的对象。</p>
<p><strong>无法解决继承问题，</strong> 因为如果这个类作为基类，析构函数要设置成 virtual，然后在派生类中重写该函数，来实现多态。但此时，析构函数是私有的，派生类中无法访问。</p>
</blockquote>
<p><strong>解决方法2：</strong></p>
<p>构造函数设置为 protected，并提供一个** public 的静态函数来完成构造**，而不是在类的外部使用 new 构造；将析构函数设置为 protected。原因：类似于单例模式，<strong>也保证了在派生类中能够访问析构函数</strong>。通过调用 create() 函数在堆上创建对象。</p>
<blockquote>
<p>private: 只能由该类中的函数、其友元函数访问,不能被任何其他访问，该类的对象也不能访问.<br>protected: 可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问<br>public: 可以被该类中的函数、子类的函数、其友元函数访问,也可以由该类的对象访问</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> A *<span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destory</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4、限制对象建立在堆上"><a href="#4、限制对象建立在堆上" class="headerlink" title="4、限制对象建立在堆上"></a>4、限制对象建立在堆上</h2><p>由于我们利用new来分配堆空间，再调用类的构造函数构建对象。因此，我们重载 operate new()为私有，就可以限制对象建立在堆上。同时由于重载operate new（）为私有，也得重载operate delete（）；</p>
<blockquote>
<p>new和delete是C++中的表达式，用于创建一个新的对象。它们是对堆中的<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020" title="内存">内存</a>进行申请和释放，而且<strong>这两个都是不能被重载的</strong>。<strong>要实现不同的内存分配行为，需要重载operator new和operator delete而不是new和delete。</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> t)</span> </span>&#123;&#125;    <span class="comment">// 注意函数的第一个参数和返回值都是固定的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span> </span>&#123;&#125; <span class="comment">// 重载了 new 就需要重载 delete</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p><strong>1、对象建立的两种方式：</strong></p>
<p>静态建立：直接调用类的构造函数创建对象。此时对象在栈上。</p>
<p>动态建立：使用new关键字，再调用类的构造函数，A *p &#x3D; new A()。此时对象在堆上。</p>
<p><strong>2、限制对象建立在栈上</strong></p>
<p>1、设置析构函数为私有。缺点：①需要写一个销毁的成员函数用于释放内存，因为用于销毁对象的析构函数私有了，不能被外部调用。 ②无法继承</p>
<p>2、将构造函数和析构函数全部设为protected通过<strong>调用成员函数动态创建和删除(这个函数得自己写)。</strong></p>
<p>**3、限制对象建立在堆上 **</p>
<p>重载 operator new()和operator delete（）为私有</p>
]]></content>
      <categories>
        <category>c++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉SLAM十四讲-第二讲：初识SLAM</title>
    <url>/2022/08/26/%E8%A7%86%E8%A7%89SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2%E4%B9%8B%E7%AC%AC%E4%BA%8C%E8%AE%B2/</url>
    <content><![CDATA[<p>本文主要介绍视觉SLAM十四讲中第二讲的关键内容。</p>
<span id="more"></span>
<h2 id="第二讲：初识SLAM"><a href="#第二讲：初识SLAM" class="headerlink" title="第二讲：初识SLAM"></a>第二讲：初识SLAM</h2><p>一类传感器是<strong>携带于机器人本体上</strong>的，例如机器人的轮式编码器、相机、激光等等 ——通过间接测量数据推算位置，好处是对环境没有提出要求，适用于位置环境。</p>
<p>一类是<strong>安装于环境中</strong>的，例如前面讲的导轨、二维码标志等等。   —— 约束了外界环境，限制了使用范围</p>
<blockquote>
<p>📌</p>
<p><strong>单目相机</strong>是三维空间的二维投影，因此，如果想恢复三维结构，必须移动相机的视角。</p>
<p>因此，<strong>单目相机平移之后才能计算深度，并且无法确定真实尺度</strong>，问题的本质在于通过单张图像无法确定深度。</p>
</blockquote>
<blockquote>
<p>📌<strong>双目相机</strong>和<strong>深度相机</strong>，目的在于通过某种手段测量物体距离我们的距离，回复距离信息，因此场景的三维结构可以通过单张图线回复，也就消除了尺度不确定性。</p>
<p>双目相机测量到的深度范围与基线相关。基线距离越大，能够测量到的就越远</p>
<p><strong>双目或多目相机的缺点</strong>是配置与标定均较为复杂，其深度量程和精度受双目的基线与分辨率限制，而且视差的计算非常消耗计算资源</p>
<p><strong>深度相机</strong>（又称 RGB-D 相机)右开始兴起的一种相机，它最大的特点是可以通过红外结构光或 Time-of-Flight（ToF）原理，像激光传感器那样，通过主动向物体发射光并接收返回的光，测出物体离相机的距离。<strong>区别于双目相机是采用计算的方式获得深度，深度相机是通过物理方式，避免了大量的计算。</strong></p>
</blockquote>
<p>视觉里程计只计算相邻时刻的运动，而和再往前的过去的信息没有关联。仅通过视觉里程计估计轨迹，将不可避免的出现累积漂移。每次估计都会有一定的误差，由于里程计只估计相邻时刻的运动，先前时刻的误差将会传递到下一时刻，导致一段时间后估计的轨迹不再准确。</p>
<p>后端优化主要指处理 SLAM 过程中噪声的问题。后端优化要考虑的问题，就是如何从这些带有噪声的数据中，估计整个系统的状态，以及这个状态估计的不确定性有多大——这称为最大后验概率估（Maximum-a-Posteriori，MAP）。</p>
<p>为了实现回环检测，我们需要让机器人具有识别曾到达过的场景的能力。</p>
<blockquote>
<p>📌<strong>SLAM问题的数学表述</strong></p>
<p><img data-src="https://s2.loli.net/2022/08/26/HR8BbFdckGSAUpP.png" alt="SLAM运动和观测方程.png"></p>
<p>方程1是运动方程，方程2是观测方程</p>
<p>其中uk代表传感器输入，z代表传感器观测，y代表路标。</p>
<p>运动方程:  相机是六自由度姿态，两次位姿之间的关系相差一个旋转矩阵。</p>
<p>观测方程：z是在xk位置观测到yj所产生的观测数据。例如，在xk看到一个特征点，获得他的像素坐标[u,v]，由三维空间点获得像素坐标，这是<strong>相机模型。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>视觉SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>上传项目至Github并修改init主分支为main</title>
    <url>/2022/08/29/%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E8%87%B3GitHub,%E5%B9%B6%E4%BF%AE%E6%94%B9init%E4%B8%BB%E5%88%86%E6%94%AF%E4%B8%BAmain/</url>
    <content><![CDATA[<p>摘要：本文介绍了如何将本地项目上传至GitHub，并修改init主分支为main。</p>
<span id="more"></span>
<h2 id="1、创建项目"><a href="#1、创建项目" class="headerlink" title="1、创建项目"></a>1、创建项目</h2><p>首先，我们需要在LeetCode创建一个自己的项目，并利用Add readme自动初始化项目。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208291939784.png"></p>
<p>本文默认已经配置了SSH公钥。</p>
<h2 id="2、修改init的默认分支"><a href="#2、修改init的默认分支" class="headerlink" title="2、修改init的默认分支"></a>2、修改init的默认分支</h2><p>在2020年10月1起，github默认主分支从master更名为main，以上提交方式会默认创建一个master分支，为保持一致性，可将本地git init的时候默认分支修改为main，执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git --version    查看版本</span><br><span class="line">git config --global init.defaultBranch main   git在2.28.0上，重新设置git默认分支为main</span><br></pre></td></tr></table></figure>

<p>如果不小心创建了master分支，可以执行命令删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">删除本地分支：git branch -d 分支名称</span><br><span class="line">强制删除本地分支：git branch -D 分支名称</span><br><span class="line">删除远程分支：git push origin --delete 分支名称</span><br></pre></td></tr></table></figure>

<h2 id="3、第一次项目提交"><a href="#3、第一次项目提交" class="headerlink" title="3、第一次项目提交"></a>3、第一次项目提交</h2><h3 id="①-初始化git"><a href="#①-初始化git" class="headerlink" title="① 初始化git"></a>① 初始化git</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<h3 id="②-添加文件到缓存区"><a href="#②-添加文件到缓存区" class="headerlink" title="② 添加文件到缓存区"></a>② 添加文件到缓存区</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208291939230.png"></p>
<h3 id="③-提交说明"><a href="#③-提交说明" class="headerlink" title="③ 提交说明"></a>③ 提交说明</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;需要注释的内容&quot;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208291939775.png"></p>
<h3 id="④-链接到项目"><a href="#④-链接到项目" class="headerlink" title="④ 链接到项目"></a>④ 链接到项目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin http://xxxxxxxxx.git   //本地仓库和远程github关联</span><br></pre></td></tr></table></figure>

<h3 id="⑤-第一次提交需要拉取项目中的readme"><a href="#⑤-第一次提交需要拉取项目中的readme" class="headerlink" title="⑤ 第一次提交需要拉取项目中的readme"></a>⑤ 第一次提交需要拉取项目中的readme</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull --rebase origin main</span><br></pre></td></tr></table></figure>

<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208291939043.png"></p>
<h3 id="⑥-推送至远程GIT-项目合并"><a href="#⑥-推送至远程GIT-项目合并" class="headerlink" title="⑥ 推送至远程GIT 项目合并"></a>⑥ 推送至远程GIT 项目合并</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208291939631.png"></p>
<p>特地强调一下 -u 操作。在我们第一次提交git的时候使用这个参数，在以后我们要进行二次提交的时候，就可以用</p>
<p><code>git push</code>代替 <code>git push origin main</code>.</p>
<h2 id="4、更新结果"><a href="#4、更新结果" class="headerlink" title="4、更新结果"></a>4、更新结果</h2><p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208291939457.png"></p>
<h2 id="5、下一次提交？"><a href="#5、下一次提交？" class="headerlink" title="5、下一次提交？"></a>5、下一次提交？</h2><p>我们希望持续的维护一个项目，就会对代码进行修改，修改后，再次提交。</p>
<p>为了展示如何修改，修改项目中的文件，并增加新的文件 1、两数之和。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208291939832.png"></p>
<p>在本地的代码指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status   //查看有哪些文件修改</span><br><span class="line">git add 文件名   //哪些文件要提交</span><br><span class="line">git add .       //全部添加到暂存区</span><br><span class="line">git add -A        //所有修改、增加、删除都添加到暂存区</span><br><span class="line">git commit  -m &quot;注释&quot;     //提交 </span><br><span class="line">git push      //推送</span><br></pre></td></tr></table></figure>

<p>如果想直接提交所有修改文件，命令可以更简洁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -a  -m &quot;注释&quot;    //提交所有修改</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>这样就完成了再次提交。</p>
<p>本文到此就结束啦，希望对你有所帮助。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>解决typora提示:This beta version of Typora is expired</title>
    <url>/2022/08/27/%E8%A7%A3%E5%86%B3typora%E6%8F%90%E7%A4%BAThis%20beta%20version%20of%20Typora%20is%20expired/</url>
    <content><![CDATA[<p>解决typora提示This beta version of Typora is expired, please download and install a newer version<br>自从typora付费之后也没有怎么使用，后来做git仓库+picgo+typora联动的时候，再次打开typora，弹出了以下窗口：</p>
<span id="more"></span>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208271020322.png" alt="ERROR提示"></p>
<p>我重新下载了付费版本的typora然后然后开启了15天尝鲜。但是我发现之后再想用typora打开md文档的时候依然会出现这个提示框，并且无论是点击确定还是×掉都依然会跳转到typora的安装界面。</p>
<p>这个错误提示大概的意思就是beta版本的typora已经过，需要下载最新版本。</p>
<p>在网上查找了一圈解决办法，目前通过修改注册表解决了我的问题。</p>
<p>以下是解决步骤：</p>
<p>1、win+r 打开运行窗口 &amp;#x20;<br>2、在搜索栏输入regedit，回车后打开注册表 &amp;#x20;<br>3、在注册表中找到：计算机\HKEY_CURRENT_USER\Software\Typora &amp;#x20;<br>4、鼠标右键Typora，选择权限 &amp;#x20;<br>5、选择Administraors，将下面的权限选择为拒绝</p>
<p>点击应用的时候可能会出现提醒，点确定就行了。最后保存设置。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208271021324.png" alt="修改typora权限"></p>
<p>6、重新打开typora，就可以正常应用了。</p>
<p>以上就是问题的解决方法。</p>
]]></content>
      <categories>
        <category>一些奇奇怪怪的问题之windows</category>
      </categories>
      <tags>
        <tag>typora</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉SLAM十四讲-第三讲：三维空间刚体运动</title>
    <url>/2022/08/28/%E8%A7%86%E8%A7%89SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2%E4%B9%8B%E7%AC%AC%E4%B8%89%E8%AE%B2/</url>
    <content><![CDATA[<h2 id="第三讲：三维空间刚体运动"><a href="#第三讲：三维空间刚体运动" class="headerlink" title="第三讲：三维空间刚体运动"></a>第三讲：三维空间刚体运动</h2><p><strong>利用旋转+平移描述三维空间刚体的运动</strong></p>
<span id="more"></span>

<p>向量在一个坐标系下的坐标表示：</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321796.png"></p>
<p>即在以基底为（e1,e2,e3）的坐标系下，向量的坐标为（a1,a2,a3）</p>
<blockquote>
<p>📌向量的内积，即向量的点乘。描述了两个向量间的投影关系，</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321495.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321030.png"></p>
</blockquote>
<blockquote>
<p>📌向量的外积，即向量的叉乘。得到了第三个向量，这个向量，垂直于这两个向量。</p>
<p>这个关系描述子向量间的旋转</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321232.png"></p>
<p>其中n是a和b构成的平面的单位向量</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321246.png"></p>
<p>外积只对三维向量存在定义。</p>
<p>上式中的定义，将外积转化为了矩阵的乘法，也是成立的。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321069.png"></p>
<p>在旋转向量的方向就是a x b的方向，大小由ab的夹角决定。 右手法则，攥住旋转轴，手指的旋转方向就是旋转方向，大小就是这个旋转向量的大小。因此，由向量的外积可以表示一个旋转，一个轴代表方向，一个夹角，后面会引入旋转向量。</p>
</blockquote>
<blockquote>
<p>📌<strong>坐标系间的欧式变换</strong></p>
<p>相机运动是一个刚体运动，<strong>它保证了同一个向量在各个坐标系下的长度和夹角都不会</strong></p>
<p>发生变化。这种变换称为欧氏变换。</p>
<p><strong>这种变换最大的特点就是改变物体的空间位置但是不改变物体的形状、大小，即不改变向量的方向和大小。</strong></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321564.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321019.png"></p>
<p>旋转矩阵是行列式为1的正交矩阵，正交矩阵是本身转置等于本身逆的矩阵。</p>
<p>旋转矩阵的逆描述了一个相反的旋转。</p>
<hr>
<p>因为平移向量的存在，这里的变换不是一个 线性关系，因此引入齐次坐标，重写得到<strong>变化矩阵</strong></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321926.png"></p>
<p>在三维向量的末尾添加一个1，变成四维向量，称为齐次坐标。这是一种数学技巧，这允许我们将变换变成了一个线性变换。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321055.png"></p>
<p><strong>同样，T的逆变换也代表相反的变换。</strong> 变换矩阵属于特殊的欧式群，区别于旋转矩阵，不存在转置等于逆变换。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321282.png"></p>
<p>自己的推导证明如下：</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321393.jpg"></p>
<p>变换矩阵的逆矩阵R部分直接转置，但是t部分不能直接加一个负号。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321727.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322743.png"></p>
<p>t在求逆后不是一个单纯的负号，是因为逆变换的过程中参考系发生了变化。默认SLAM，先旋转再平移，则，Tab，Rab旋转后，在平移tab，这里tab参考的是Rab旋转后的坐标系，即虚线表示的坐标系。反过来，B旋转Rba，即Rab的转置（逆），这里的状态是与A坐标系差一个平移tba。tab的参考系是Rab点乘A，但现在的参考系是Rba点乘B，所以要将tab变换到Rba点乘B下面，在进行负变换，因此对-tab做成Rab的转置（逆）。</p>
<p>再从运算的角度进行分析：</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322432.png"></p>
<p>变换的合成是不断的左乘位姿变换矩阵。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322374.png"></p>
<p>APE，绝对位姿误差：每个时刻的位姿和真实位姿之间的误差计算。</p>
<p>RPE，相对位姿误差：相邻时刻的相对位姿变化与真实相对位姿变换间的误差</p>
<p>有关RPE和APE可以进一步参考</p>
<p><a href="http://zhaoxuhui.top/blog/2021/05/14/APE-RPE-ATE-RTE-Mmetric-in-SLAM.html" title="http://zhaoxuhui.top/blog/2021/05/14/APE-RPE-ATE-RTE-Mmetric-in-SLAM.html">http://zhaoxuhui.top/blog/2021/05/14/APE-RPE-ATE-RTE-Mmetric-in-SLAM.html</a></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322658.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322721.png"></p>
<p>根据计算方式，其实我们也就很容易知道RPE的好处了，RPE只使用位姿的变化而不关心估计的绝对位姿，因此消除了估计的绝对位置对于最终结果的影响。APE中每个绝对位姿都是相对于绝对坐标系的，因此含有绝对位置的影响。</p>
</blockquote>
<blockquote>
<p>📌Eigen&#x2F;库的理论实践</p>
<p>Eigen库的神奇之处在于它是一个完全用头文件搭建的库，没有.so或.a 那样的二进制文件。</p>
<p>我们在使用时，只需引入 Eigen 的头文件即可，不需要链接它的库文件（因为它没有库文</p>
<p>件）。</p>
<p>重复一遍，因为 Eigen 库只有头文件，我们不需要再用 tartget_link_libraries 语句将程序链接到库上。不过，对于其他大部分库，多数时候需要用到链接命令。</p>
</blockquote>
<blockquote>
<p>📌<strong>旋转向量</strong></p>
<p>为什么要引入旋转向量？</p>
<p>A：旋转使三自由度运动，平移也是三自由度运动，为了描述一个六自由度变换，变换矩阵采用了16个元素，造成表达非常不紧凑，同理旋转矩阵。</p>
<p>旋转矩阵自身带有约束：它必须是个正交矩阵，且行列式为 1。<strong>变换矩阵也是如此（因为变换矩阵包含了旋转矩阵）。</strong> 当我们想要估计或优化一个旋转矩阵&#x2F;变换矩阵时，这些约束会使得求解变得更困难。</p>
<p>为了表达更加紧凑，引入了旋转向量。</p>
<p>任意旋转都可以用一个旋转轴和一个旋转角来刻画。于是，我们可以使用一个向量，<strong>其方向与旋转轴一致，而长度等于旋转角</strong>。这种向量，称为旋转向量。</p>
<p>由旋转向量到旋转矩阵的过程由<strong>罗德里格斯公式（Rodrigues’s Formula ）</strong> 表明：</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322494.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322233.png"></p>
<p>旋转矩阵特征值为1时对应的特征向量，|R-λE|&#x3D;0，特征值为1，说明旋转矩阵为单位矩阵，说明在这个特征向量（解）上没有旋转变化，转轴上的旋转没有旋转变化，所以对应的特征向量就是转轴。求解矩阵R特征值为1时候的特征向量就得到了旋转轴。利用式3.16求得转角，就获得了<strong>旋转向量。</strong></p>
<p>这里共涉及到两种变换，假设一个旋转轴为 n ,角度为θ的旋转。</p>
<ol>
<li><p>从旋转向量到旋转矩阵的变换：罗德里格斯公式。</p>
</li>
<li><p>从旋转矩阵到旋转向量的变换。 &amp;#x20;</p>
<p>①.对 θ :  公式3.16</p>
<p>②.对 n ：转轴 n ，是矩阵 R 特征值1对应的特征向量。</p>
<p><img data-src="/image/image_nsoQdMmLFK.png"></p>
</li>
</ol>
</blockquote>
<blockquote>
<p>📌<strong>欧拉角</strong></p>
<p>无论是旋转矩阵还是旋转向量，都是数学的形式，不能很直观的反应旋转的形式。欧拉角将旋转分解为了绕三个固定轴的旋转。</p>
<p>欧拉角当中比较常用的一种，便是用“偏航-俯仰-滚转”（yaw-pitch-roll）三个角度来描述一个旋转的。它等价于 ZY X 轴的旋转。在右手坐标系中进行记忆：</p>
<ol>
<li><p>绕物体的 Z 轴旋转，得到偏航角 yaw；</p>
</li>
<li><p>绕旋转之后的 Y 轴旋转，得到俯仰角 pitch；</p>
</li>
<li><p>绕旋转之后的 X 轴旋转，得到滚转角 roll。</p>
</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322394.png"></p>
<p><img data-src="/image/image_icJyhksFNx.png"></p>
<hr>
<p>欧拉角中最大的问题是万向锁，这种现象被称为具有奇异性，例如应用zxy的转法，首先改变偏航角，再改变滚转角，再改变俯仰角。如果第二次旋转，滚转角为90度，则第三次旋转将会变得与第一次旋转相同，就丢失了一个自由度。相当于第二次如果转90度，x就跑到了原本z轴的位置，那么第三次旋转就和第一次一样，那么就变成了三次旋转只转了两次。丢失了一个自由度。其他欧拉角旋转方式也具有类似的问题。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322362.png"></p>
<p>欧拉角常用于人机交互，在SLAM中不常用。</p>
</blockquote>
<blockquote>
<p>📌<strong>四元数</strong></p>
<p>三维旋转是一个三维流形，想要无奇异性地表达它，用三个量是不够的。</p>
<p><strong>四元数是一种扩展的复数。</strong> 一个实部和三个虚部。</p>
<p>实部为0，虚四元数，虚部为0，实四元数</p>
<p>因此，在四元数中，任意的旋转都可以由两个互为相反数的四元数表示。</p>
<p>四元数的共轭是把虚部取成相反数</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322828.png"></p>
<p>四元数共轭与自己本身相乘，会得到一个实四元数，其实部为模长的平方:</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322894.png"></p>
<p>两个单位四元数相乘后依然是单位四元数。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322950.png"></p>
<p>单位四元数的逆和共轭相等</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322786.jpg"></p>
<p><strong>用四元数表示旋转</strong></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322493.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322067.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322697.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262323777.jpg"></p>
<p>旋转矩阵、旋转向量、四元数之间可以相互转化。由于上述推算的方法需要计算arcos不太划算，所以，采用另一种方法跳过这个计算，如下：</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262323373.png"></p>
<p>由于 q 和 −q 表示同一个旋转，事实上一个 R 对应的四元数表示并不是唯一的。</p>
</blockquote>
<blockquote>
<p>📌<strong>相似、仿射、射影变换</strong></p>
<p>欧氏变换保持了向量的长度和夹角，是一个刚体运动，形状是不变的。</p>
<p><strong>相似变换</strong>比欧氏变换多了一个自由度，允许物体进行均匀的缩放。但是是成比例的。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262323336.png"></p>
<p><strong>仿射变换</strong>只要求A是一个可逆矩阵而不必是正交矩阵，仿射变换也叫正交投影，经过仿射变换之后，立方体就不再是方的了，但是各个面仍然是平行四边形。保持了平直性和平行性，但是角度会变。变换后直线还是直线，圆弧还是圆弧。平行线还是平行线，直线上点的位置顺序不变</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262323413.png"></p>
<p><strong>射影变换</strong>是最一般的变化。二维8自由度，三维15自由度。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262323362.png"></p>
<p><strong>从真实世界到相机照片的变换是一个射影变换。如果相机的焦距为无穷远，那么这个变换则为仿射变换。</strong></p>
<p>三维空间下，四种变换的自由度区别。</p>
<p>欧式变换   6自由度   三个轴，每个轴有平移和旋转，3x2&#x3D;6</p>
<p>相似变换   7自由度  成比例缩放  多加一个自由度   7</p>
<p>仿射变换   12 自由度 三个轴，每个轴缩放、旋转、平移、倾斜  3x4&#x3D;12 如果是2维，则是6自由度</p>
<p>&amp;#x20;             另一个角度，从公式去理解 A9个元素，t三个元素，12个元素变换都影响结果。因此  &amp;#x20;</p>
<p>&amp;#x20;             是12自由度</p>
<p>射影变换  从公式来看v不等于0时，这个变换矩阵是是齐次的。否则右下角一直为0，也没变化，没意义。那么4x4&#x3D;16的矩阵里，只有1 不变，那么是15自由度。如果对于二维空间，那齐次矩阵就变成了3x3-1&#x3D;8，因此二维空间的射影变换是8自由度。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262323054.png"></p>
<p>二维中，一个点有两个自由度。</p>
<p>真实世界拍照是射影变换，如果焦距无限远就变成了仿射变换。射影变换只保留了点的共线性，平行性消失了。</p>
</blockquote>
<blockquote>
<p>📌Eigen使用总结</p>
</blockquote>
<blockquote>
<p>📌<strong>值得做的习题，证明方面的。</strong></p>
<ol>
<li><p>验证旋转矩阵是正交矩阵。</p>
</li>
<li><p>&amp;#x20;一般线程方程 Ax &#x3D; b 有哪几种做法？你能在 Eigen 中实现吗？</p>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>视觉SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
</search>
