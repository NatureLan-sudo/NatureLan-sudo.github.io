<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>五星 C++ 内存管理</title>
    <url>/2022/09/01/%E4%BA%94%E6%98%9FC++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20-2022-08-29/</url>
    <content><![CDATA[<p>C++ 内存分区：<strong>栈、堆、全局&#x2F;静态存储区、常量存储区、代码区</strong>。</p>
<span id="more"></span>

<p><strong>栈</strong>：存放函数的局部变量、函数参数、返回地址等，<strong>由编译器自动分配和释放</strong>。</p>
<blockquote>
<p>栈是线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，就是切换SS&#x2F;ESP寄存器。栈空间不需要在高级语言里面显式的分配和释放。</p>
</blockquote>
<p><strong>堆</strong>：动态申请的内存空间，就是由 **malloc **分配的内存块，<strong>由程序员控制它的分配和释放</strong>，如果程序执行结束还没有释放，操作系统会自动回收。（是可能会会释放，所以说，用完了一定记得要释放，不然会造成内存泄露）。</p>
<blockquote>
<p>堆一般由程序员分配释放，若不释放，程序结束时可能由OS回收。注意这里说是可能，并非一定。所以我想再强调一次，记得要释放！注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</p>
<p>当内存不再使用的时候，应使用free()函数将内存块释放掉。</p>
</blockquote>
<p><strong>全局区&#x2F;静态存储区（.bss 段和 .data 段）</strong>：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。</p>
<blockquote>
<p>解释一下静态变量</p>
<p>静态变量通过关键字static进行声明。</p>
<p>经static修饰过后的变量或者函数的作用域会发生变化。该变量存储在数据段上，可以改变变量的作用域和生命周期。</p>
<p><strong>全局静态变量</strong></p>
<p>在全局变量前面加上关键词static，全局变量就被定义成一个全局静态变量</p>
<p>（1）内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）</p>
<p>（2）初始化：未经初始化的全局静态变量会被程序自动初始化为0</p>
<p>（3）作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。</p>
<p><strong>局部静态变量</strong></p>
<p>在局部变量前面加上关键词static，局部变量就被定义成一个局部静态变量。</p>
<p>（1）内存中的位置：静态存储区</p>
<p>（2）初始化：未经初始化的局部静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）</p>
<p>（3）作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。</p>
<p><strong>C语言中使用静态函数的好处</strong></p>
<p>（1）静态函数会被自动分配在一个一直使用的存储区，直到退出程序，<strong>避免了调用函数的压栈出栈</strong>，速度快很多。</p>
<p>（2）static指函数的作用域仅局限于本文件。不<strong>用担心自己定义的函数是否会与其他文件的函数同名</strong></p>
</blockquote>
<p><strong>常量存储区（.data 段）</strong>：存放的是<strong>常量，不允许修改</strong>，程序运行结束自动释放。<br><strong>代码区（.text 段）</strong>：<strong>存放代码，不允许修改</strong>，但可以执行。编译后的二进制文件存放在这里。<br>说明：</p>
<p>从操作系统的本身来讲，以上存储区在内存中的分布是如下形式(从低地址到高地址)：</p>
<p><strong>.text 段 –&gt; .data 段 –&gt; .bss 段 –&gt; 堆 –&gt; unused –&gt; 栈 –&gt; env</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明：C++ 中不再区分初始化和未初始化的全局变量、静态变量的存储区，如果非要区分下述程序标注在了括号中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_var = <span class="number">0</span>; <span class="comment">// g_var 在全局区（.data 段）</span></span><br><span class="line"><span class="type">char</span> *gp_var;  <span class="comment">// gp_var 在全局区（.bss 段）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> var;                    <span class="comment">// var 在栈区</span></span><br><span class="line">    <span class="type">char</span> *p_var;                <span class="comment">// p_var 在栈区</span></span><br><span class="line">    <span class="type">char</span> arr[] = <span class="string">&quot;abc&quot;</span>;         <span class="comment">// arr 为数组变量，存储在栈区；&quot;abc&quot;为字符串常量，存储在常量区</span></span><br><span class="line">    <span class="type">char</span> *p_var1 = <span class="string">&quot;123456&quot;</span>;    <span class="comment">// p_var1 在栈区；&quot;123456&quot;为字符串常量，存储在常量区</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_var = <span class="number">0</span>;       <span class="comment">// s_var 为静态变量，存在静态存储区（.data 段）</span></span><br><span class="line">    p_var = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>); <span class="comment">// 分配得来的 10 个字节的区域在堆区</span></span><br><span class="line">    <span class="built_in">free</span>(p_var);                <span class="comment">// 因为使用了malloc堆的空间，由程序员自己释放掉</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：力扣 (LeetCode)</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/leetbook/read/cpp-interview-highlights/e4vkxv/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>五星 C++ 堆和栈的区别</title>
    <url>/2022/09/02/%E4%BA%94%E6%98%9F%20C++%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E5%8C%BA%E5%88%AB%20%20%20-%20%20%20%202022-08-29/</url>
    <content><![CDATA[<p><strong>申请方式：</strong> 栈是系统自动分配，堆是程序员主动申请。<strong>申请后系统响应：</strong>分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。<br>栈在内存中是连续的一块空间（向低地址扩展）<strong>最大容量是系统预定好的</strong>，堆在内存中的空间（向高地址扩展）是<strong>不连续</strong>的。<br><strong>申请效率：</strong> 栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。<br><strong>存放的内容：</strong> 栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。</p>
<span id="more"></span>

<p><strong>问题1：堆的内存为什么是不连续的</strong></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209021418598.png"></p>
<p><strong>问题2：堆和栈的不同点</strong></p>
<p>管理方式：堆-程序员。栈-系统。</p>
<p>空间大小：堆-不确定。栈-最大容量是系统设定好的。</p>
<p>生长方向：堆-向高地址扩展，不连续。栈-向低地址扩展，连续。</p>
<p>分配效率：堆-程序员申请，效率低，容易产生碎片。栈-系统分配，效率高，但是程序员不能控制。</p>
<p>存放内容：堆-程序员自己申请的内容。栈-局部变量，函数参数等。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202209021418580.png"></p>
]]></content>
      <categories>
        <category>C++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>四星 C++ 变量的区别</title>
    <url>/2022/09/04/%E5%9B%9B%E6%98%9F%20C++%20%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB-2022-08-30/</url>
    <content><![CDATA[<p>全局变量、局部变量、静态全局变量、静态局部变量的区别<br>C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。</p>
<span id="more"></span>
<p>从作用域看：</p>
<p><strong>全局变量：</strong> 具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量。</p>
<p><strong>静态全局变量：</strong>具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，<strong>它作用于定义它的文件里，不能作用到其它文件里</strong>，即被 static 关键字修饰过的变量具有文件作用域。这样即使<strong>两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</strong></p>
<p><strong>局部变量：</strong>具有局部作用域。它是自动对象（auto），在程序运行期间<strong>不是一直存在</strong>，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。</p>
<p><strong>静态局部变量：</strong>具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都<strong>一直存在</strong>，<strong>它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。</strong><br>从分配内存空间看：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于数据来说，声明和定义往往是同时存在的，比如下面的一行语句,既定义也声明了。</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//只声明不定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> data;</span><br><span class="line"><span class="comment">//对于函数来说，函数声明一般写在头文件中，函数的定义一般写在源文件中；</span></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">helloworld</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">helloworld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用变量之前必须声明，声明可以有多次，而定义只能有一次。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>静态存储区：</strong> 全局变量，静态局部变量，静态全局变量。<br><strong>栈：</strong> 局部变量。</p>
<p>静态变量和栈变量（存储在栈中的变量）、堆变量（存储在堆中的变量）的区别：<strong>静态变量会被放在程序的静态数据存储区（.data 段）中（静态变量会自动初始化），这样可以在下一次调用的时候还可以保持原来的赋值。</strong> 而栈变量或堆变量不能保证在下一次调用的时候依然保持原来的值。</p>
<p>静态变量是通过区分存放位置来保证其特殊的生命周期的。栈变量程序会自动释放。堆变量要由程序员自己释放。<br>静态变量和全局变量的区别：静态变量用 static 告知编译器，<strong>自己仅仅在变量的作用范围内可见</strong></p>
<blockquote>
<p>对于静态全局变量，只在该文件中生效，在其他文件中不生效，因此，在其他文件中，可以定义同名的静态全局变量。</p>
<p>对于静态局部变量，在局部函数体中，只要被初始化，就会一直存在，不会被释放。</p>
<p>全局变量，定义后，在其他文件中声明，就可以使用，不能存在同名的定义。并不需要引用头文件文件，但是依然可以在不同文件间共享变量和函数，这一切都是extern的功劳！</p>
</blockquote>
<p>××××</p>
<p>**全局变量定义在头文件中会出现什么问题 **</p>
<blockquote>
<p>如果在头文件中定义全局变量，当该头文件被多个文件 <code>include</code> 时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能再头文件中定义全局变量。</p>
</blockquote>
<p>include一个头文件，相当于把他带包写到了另一个文件，就会被多次定义。</p>
<p><strong>所以全局变量应该被定义在源文件中。</strong> 其他程序使用，利用extern进行声明。</p>
]]></content>
      <categories>
        <category>C++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>上传项目至Github并修改init主分支为main</title>
    <url>/2022/08/29/%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E8%87%B3GitHub,%E5%B9%B6%E4%BF%AE%E6%94%B9init%E4%B8%BB%E5%88%86%E6%94%AF%E4%B8%BAmain/</url>
    <content><![CDATA[<p>摘要：本文介绍了如何将本地项目上传至GitHub，并修改init主分支为main。</p>
<span id="more"></span>
<h2 id="1、创建项目"><a href="#1、创建项目" class="headerlink" title="1、创建项目"></a>1、创建项目</h2><p>首先，我们需要在LeetCode创建一个自己的项目，并利用Add readme自动初始化项目。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208291939784.png"></p>
<p>本文默认已经配置了SSH公钥。</p>
<h2 id="2、修改init的默认分支"><a href="#2、修改init的默认分支" class="headerlink" title="2、修改init的默认分支"></a>2、修改init的默认分支</h2><p>在2020年10月1起，github默认主分支从master更名为main，以上提交方式会默认创建一个master分支，为保持一致性，可将本地git init的时候默认分支修改为main，执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git --version    查看版本</span><br><span class="line">git config --global init.defaultBranch main   git在2.28.0上，重新设置git默认分支为main</span><br></pre></td></tr></table></figure>

<p>如果不小心创建了master分支，可以执行命令删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">删除本地分支：git branch -d 分支名称</span><br><span class="line">强制删除本地分支：git branch -D 分支名称</span><br><span class="line">删除远程分支：git push origin --delete 分支名称</span><br></pre></td></tr></table></figure>

<h2 id="3、第一次项目提交"><a href="#3、第一次项目提交" class="headerlink" title="3、第一次项目提交"></a>3、第一次项目提交</h2><h3 id="①-初始化git"><a href="#①-初始化git" class="headerlink" title="① 初始化git"></a>① 初始化git</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<h3 id="②-添加文件到缓存区"><a href="#②-添加文件到缓存区" class="headerlink" title="② 添加文件到缓存区"></a>② 添加文件到缓存区</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208291939230.png"></p>
<h3 id="③-提交说明"><a href="#③-提交说明" class="headerlink" title="③ 提交说明"></a>③ 提交说明</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;需要注释的内容&quot;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208291939775.png"></p>
<h3 id="④-链接到项目"><a href="#④-链接到项目" class="headerlink" title="④ 链接到项目"></a>④ 链接到项目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin http://xxxxxxxxx.git   //本地仓库和远程github关联</span><br></pre></td></tr></table></figure>

<h3 id="⑤-第一次提交需要拉取项目中的readme"><a href="#⑤-第一次提交需要拉取项目中的readme" class="headerlink" title="⑤ 第一次提交需要拉取项目中的readme"></a>⑤ 第一次提交需要拉取项目中的readme</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull --rebase origin main</span><br></pre></td></tr></table></figure>

<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208291939043.png"></p>
<h3 id="⑥-推送至远程GIT-项目合并"><a href="#⑥-推送至远程GIT-项目合并" class="headerlink" title="⑥ 推送至远程GIT 项目合并"></a>⑥ 推送至远程GIT 项目合并</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208291939631.png"></p>
<p>特地强调一下 -u 操作。在我们第一次提交git的时候使用这个参数，在以后我们要进行二次提交的时候，就可以用</p>
<p><code>git push</code>代替 <code>git push origin main</code>.</p>
<h2 id="4、更新结果"><a href="#4、更新结果" class="headerlink" title="4、更新结果"></a>4、更新结果</h2><p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208291939457.png"></p>
<h2 id="5、下一次提交？"><a href="#5、下一次提交？" class="headerlink" title="5、下一次提交？"></a>5、下一次提交？</h2><p>我们希望持续的维护一个项目，就会对代码进行修改，修改后，再次提交。</p>
<p>为了展示如何修改，修改项目中的文件，并增加新的文件 1、两数之和。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208291939832.png"></p>
<p>在本地的代码指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status   //查看有哪些文件修改</span><br><span class="line">git add 文件名   //哪些文件要提交</span><br><span class="line">git add .       //全部添加到暂存区</span><br><span class="line">git add -A        //所有修改、增加、删除都添加到暂存区</span><br><span class="line">git commit  -m &quot;注释&quot;     //提交 </span><br><span class="line">git push      //推送</span><br></pre></td></tr></table></figure>

<p>如果想直接提交所有修改文件，命令可以更简洁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -a  -m &quot;注释&quot;    //提交所有修改</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>这样就完成了再次提交。</p>
<p>本文到此就结束啦，希望对你有所帮助。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>四星 C++ 程序编译过程</title>
    <url>/2022/08/31/%E5%9B%9B%E6%98%9FC++%20%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%20-%202022-08-28/</url>
    <content><![CDATA[<p>编译过程可以分为以下三个过程：编译（编译预处理、编译、优化），汇编，链接。<br>其中编译又可以分为编译预处理以及编译优化，就可以划分为四部分。</p>
<span id="more"></span>

<h2 id="1、编译预处理"><a href="#1、编译预处理" class="headerlink" title="1、编译预处理"></a>1、编译预处理</h2><p>编译预处理：处理以 # 开头的指令；</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SOMEFILE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOMEFILE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta">#program once</span></span><br></pre></td></tr></table></figure>

<h2 id="2、编译、优化"><a href="#2、编译、优化" class="headerlink" title="2、编译、优化"></a>2、编译、优化</h2><p>将源码 .cpp 文件翻译成 .s 汇编代码；</p>
<h2 id="3、汇编"><a href="#3、汇编" class="headerlink" title="3、汇编"></a>3、汇编</h2><p>将汇编代码 .s 翻译成机器指令 .o 文件；</p>
<h2 id="4、链接"><a href="#4、链接" class="headerlink" title="4、链接"></a>4、链接</h2><p>汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。</p>
<p><strong>链接包括静态链接和动态链接</strong></p>
<p><strong>静态链接</strong>：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</p>
<p>通俗的讲：静态链接将程序调用的库一起打包到可执行文件中，这样执行时候就不用调用其他的库，速度快。但是，可能多个文件都链接了同一个库，那么这个库就被打包了很多次，造成了该空间上的浪费。如果这个库更新了的话，整个程序需要重新编译。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208302038882.png" alt="静态链接"></p>
<p><strong>动态链接</strong>：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</p>
<p>通俗的讲：动态链接是在程序执行时候才引入的库，因此方便更新。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208302038200.png" alt="动态链接"></p>
<p>二者的优缺点：</p>
<p>静态链接：<strong>浪费空间，</strong>每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序<strong>（更新困难）</strong>；优点就是执行的时候运行<strong>速度快，</strong> 因为可执行程序具备了程序运行的所有内容。<br>动态链接：<strong>节省内存、更新方便</strong>，但是动态链接是在程序运行时，每次执行都需要链接，<strong>相比静态链接会有一定的性能损失。</strong></p>
]]></content>
      <categories>
        <category>C++突击</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉SLAM十四讲-第三讲：三维空间刚体运动</title>
    <url>/2022/08/28/%E8%A7%86%E8%A7%89SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2%E4%B9%8B%E7%AC%AC%E4%B8%89%E8%AE%B2/</url>
    <content><![CDATA[<h2 id="第三讲：三维空间刚体运动"><a href="#第三讲：三维空间刚体运动" class="headerlink" title="第三讲：三维空间刚体运动"></a>第三讲：三维空间刚体运动</h2><p><strong>利用旋转+平移描述三维空间刚体的运动</strong></p>
<span id="more"></span>

<p>向量在一个坐标系下的坐标表示：</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321796.png"></p>
<p>即在以基底为（e1,e2,e3）的坐标系下，向量的坐标为（a1,a2,a3）</p>
<blockquote>
<p>📌向量的内积，即向量的点乘。描述了两个向量间的投影关系，</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321495.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321030.png"></p>
</blockquote>
<blockquote>
<p>📌向量的外积，即向量的叉乘。得到了第三个向量，这个向量，垂直于这两个向量。</p>
<p>这个关系描述子向量间的旋转</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321232.png"></p>
<p>其中n是a和b构成的平面的单位向量</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321246.png"></p>
<p>外积只对三维向量存在定义。</p>
<p>上式中的定义，将外积转化为了矩阵的乘法，也是成立的。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321069.png"></p>
<p>在旋转向量的方向就是a x b的方向，大小由ab的夹角决定。 右手法则，攥住旋转轴，手指的旋转方向就是旋转方向，大小就是这个旋转向量的大小。因此，由向量的外积可以表示一个旋转，一个轴代表方向，一个夹角，后面会引入旋转向量。</p>
</blockquote>
<blockquote>
<p>📌<strong>坐标系间的欧式变换</strong></p>
<p>相机运动是一个刚体运动，<strong>它保证了同一个向量在各个坐标系下的长度和夹角都不会</strong></p>
<p>发生变化。这种变换称为欧氏变换。</p>
<p><strong>这种变换最大的特点就是改变物体的空间位置但是不改变物体的形状、大小，即不改变向量的方向和大小。</strong></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321564.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321019.png"></p>
<p>旋转矩阵是行列式为1的正交矩阵，正交矩阵是本身转置等于本身逆的矩阵。</p>
<p>旋转矩阵的逆描述了一个相反的旋转。</p>
<hr>
<p>因为平移向量的存在，这里的变换不是一个 线性关系，因此引入齐次坐标，重写得到<strong>变化矩阵</strong></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321926.png"></p>
<p>在三维向量的末尾添加一个1，变成四维向量，称为齐次坐标。这是一种数学技巧，这允许我们将变换变成了一个线性变换。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321055.png"></p>
<p><strong>同样，T的逆变换也代表相反的变换。</strong> 变换矩阵属于特殊的欧式群，区别于旋转矩阵，不存在转置等于逆变换。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321282.png"></p>
<p>自己的推导证明如下：</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321393.jpg"></p>
<p>变换矩阵的逆矩阵R部分直接转置，但是t部分不能直接加一个负号。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262321727.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322743.png"></p>
<p>t在求逆后不是一个单纯的负号，是因为逆变换的过程中参考系发生了变化。默认SLAM，先旋转再平移，则，Tab，Rab旋转后，在平移tab，这里tab参考的是Rab旋转后的坐标系，即虚线表示的坐标系。反过来，B旋转Rba，即Rab的转置（逆），这里的状态是与A坐标系差一个平移tba。tab的参考系是Rab点乘A，但现在的参考系是Rba点乘B，所以要将tab变换到Rba点乘B下面，在进行负变换，因此对-tab做成Rab的转置（逆）。</p>
<p>再从运算的角度进行分析：</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322432.png"></p>
<p>变换的合成是不断的左乘位姿变换矩阵。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322374.png"></p>
<p>APE，绝对位姿误差：每个时刻的位姿和真实位姿之间的误差计算。</p>
<p>RPE，相对位姿误差：相邻时刻的相对位姿变化与真实相对位姿变换间的误差</p>
<p>有关RPE和APE可以进一步参考</p>
<p><a href="http://zhaoxuhui.top/blog/2021/05/14/APE-RPE-ATE-RTE-Mmetric-in-SLAM.html" title="http://zhaoxuhui.top/blog/2021/05/14/APE-RPE-ATE-RTE-Mmetric-in-SLAM.html">http://zhaoxuhui.top/blog/2021/05/14/APE-RPE-ATE-RTE-Mmetric-in-SLAM.html</a></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322658.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322721.png"></p>
<p>根据计算方式，其实我们也就很容易知道RPE的好处了，RPE只使用位姿的变化而不关心估计的绝对位姿，因此消除了估计的绝对位置对于最终结果的影响。APE中每个绝对位姿都是相对于绝对坐标系的，因此含有绝对位置的影响。</p>
</blockquote>
<blockquote>
<p>📌Eigen&#x2F;库的理论实践</p>
<p>Eigen库的神奇之处在于它是一个完全用头文件搭建的库，没有.so或.a 那样的二进制文件。</p>
<p>我们在使用时，只需引入 Eigen 的头文件即可，不需要链接它的库文件（因为它没有库文</p>
<p>件）。</p>
<p>重复一遍，因为 Eigen 库只有头文件，我们不需要再用 tartget_link_libraries 语句将程序链接到库上。不过，对于其他大部分库，多数时候需要用到链接命令。</p>
</blockquote>
<blockquote>
<p>📌<strong>旋转向量</strong></p>
<p>为什么要引入旋转向量？</p>
<p>A：旋转使三自由度运动，平移也是三自由度运动，为了描述一个六自由度变换，变换矩阵采用了16个元素，造成表达非常不紧凑，同理旋转矩阵。</p>
<p>旋转矩阵自身带有约束：它必须是个正交矩阵，且行列式为 1。<strong>变换矩阵也是如此（因为变换矩阵包含了旋转矩阵）。</strong> 当我们想要估计或优化一个旋转矩阵&#x2F;变换矩阵时，这些约束会使得求解变得更困难。</p>
<p>为了表达更加紧凑，引入了旋转向量。</p>
<p>任意旋转都可以用一个旋转轴和一个旋转角来刻画。于是，我们可以使用一个向量，<strong>其方向与旋转轴一致，而长度等于旋转角</strong>。这种向量，称为旋转向量。</p>
<p>由旋转向量到旋转矩阵的过程由<strong>罗德里格斯公式（Rodrigues’s Formula ）</strong> 表明：</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322494.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322233.png"></p>
<p>旋转矩阵特征值为1时对应的特征向量，|R-λE|&#x3D;0，特征值为1，说明旋转矩阵为单位矩阵，说明在这个特征向量（解）上没有旋转变化，转轴上的旋转没有旋转变化，所以对应的特征向量就是转轴。求解矩阵R特征值为1时候的特征向量就得到了旋转轴。利用式3.16求得转角，就获得了<strong>旋转向量。</strong></p>
<p>这里共涉及到两种变换，假设一个旋转轴为 n ,角度为θ的旋转。</p>
<ol>
<li><p>从旋转向量到旋转矩阵的变换：罗德里格斯公式。</p>
</li>
<li><p>从旋转矩阵到旋转向量的变换。 &amp;#x20;</p>
<p>①.对 θ :  公式3.16</p>
<p>②.对 n ：转轴 n ，是矩阵 R 特征值1对应的特征向量。</p>
<p><img data-src="/image/image_nsoQdMmLFK.png"></p>
</li>
</ol>
</blockquote>
<blockquote>
<p>📌<strong>欧拉角</strong></p>
<p>无论是旋转矩阵还是旋转向量，都是数学的形式，不能很直观的反应旋转的形式。欧拉角将旋转分解为了绕三个固定轴的旋转。</p>
<p>欧拉角当中比较常用的一种，便是用“偏航-俯仰-滚转”（yaw-pitch-roll）三个角度来描述一个旋转的。它等价于 ZY X 轴的旋转。在右手坐标系中进行记忆：</p>
<ol>
<li><p>绕物体的 Z 轴旋转，得到偏航角 yaw；</p>
</li>
<li><p>绕旋转之后的 Y 轴旋转，得到俯仰角 pitch；</p>
</li>
<li><p>绕旋转之后的 X 轴旋转，得到滚转角 roll。</p>
</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322394.png"></p>
<p><img data-src="/image/image_icJyhksFNx.png"></p>
<hr>
<p>欧拉角中最大的问题是万向锁，这种现象被称为具有奇异性，例如应用zxy的转法，首先改变偏航角，再改变滚转角，再改变俯仰角。如果第二次旋转，滚转角为90度，则第三次旋转将会变得与第一次旋转相同，就丢失了一个自由度。相当于第二次如果转90度，x就跑到了原本z轴的位置，那么第三次旋转就和第一次一样，那么就变成了三次旋转只转了两次。丢失了一个自由度。其他欧拉角旋转方式也具有类似的问题。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322362.png"></p>
<p>欧拉角常用于人机交互，在SLAM中不常用。</p>
</blockquote>
<blockquote>
<p>📌<strong>四元数</strong></p>
<p>三维旋转是一个三维流形，想要无奇异性地表达它，用三个量是不够的。</p>
<p><strong>四元数是一种扩展的复数。</strong> 一个实部和三个虚部。</p>
<p>实部为0，虚四元数，虚部为0，实四元数</p>
<p>因此，在四元数中，任意的旋转都可以由两个互为相反数的四元数表示。</p>
<p>四元数的共轭是把虚部取成相反数</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322828.png"></p>
<p>四元数共轭与自己本身相乘，会得到一个实四元数，其实部为模长的平方:</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322894.png"></p>
<p>两个单位四元数相乘后依然是单位四元数。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322950.png"></p>
<p>单位四元数的逆和共轭相等</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322786.jpg"></p>
<p><strong>用四元数表示旋转</strong></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322493.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322067.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262322697.png"></p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262323777.jpg"></p>
<p>旋转矩阵、旋转向量、四元数之间可以相互转化。由于上述推算的方法需要计算arcos不太划算，所以，采用另一种方法跳过这个计算，如下：</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262323373.png"></p>
<p>由于 q 和 −q 表示同一个旋转，事实上一个 R 对应的四元数表示并不是唯一的。</p>
</blockquote>
<blockquote>
<p>📌<strong>相似、仿射、射影变换</strong></p>
<p>欧氏变换保持了向量的长度和夹角，是一个刚体运动，形状是不变的。</p>
<p><strong>相似变换</strong>比欧氏变换多了一个自由度，允许物体进行均匀的缩放。但是是成比例的。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262323336.png"></p>
<p><strong>仿射变换</strong>只要求A是一个可逆矩阵而不必是正交矩阵，仿射变换也叫正交投影，经过仿射变换之后，立方体就不再是方的了，但是各个面仍然是平行四边形。保持了平直性和平行性，但是角度会变。变换后直线还是直线，圆弧还是圆弧。平行线还是平行线，直线上点的位置顺序不变</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262323413.png"></p>
<p><strong>射影变换</strong>是最一般的变化。二维8自由度，三维15自由度。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262323362.png"></p>
<p><strong>从真实世界到相机照片的变换是一个射影变换。如果相机的焦距为无穷远，那么这个变换则为仿射变换。</strong></p>
<p>三维空间下，四种变换的自由度区别。</p>
<p>欧式变换   6自由度   三个轴，每个轴有平移和旋转，3x2&#x3D;6</p>
<p>相似变换   7自由度  成比例缩放  多加一个自由度   7</p>
<p>仿射变换   12 自由度 三个轴，每个轴缩放、旋转、平移、倾斜  3x4&#x3D;12 如果是2维，则是6自由度</p>
<p>&amp;#x20;             另一个角度，从公式去理解 A9个元素，t三个元素，12个元素变换都影响结果。因此  &amp;#x20;</p>
<p>&amp;#x20;             是12自由度</p>
<p>射影变换  从公式来看v不等于0时，这个变换矩阵是是齐次的。否则右下角一直为0，也没变化，没意义。那么4x4&#x3D;16的矩阵里，只有1 不变，那么是15自由度。如果对于二维空间，那齐次矩阵就变成了3x3-1&#x3D;8，因此二维空间的射影变换是8自由度。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208262323054.png"></p>
<p>二维中，一个点有两个自由度。</p>
<p>真实世界拍照是射影变换，如果焦距无限远就变成了仿射变换。射影变换只保留了点的共线性，平行性消失了。</p>
</blockquote>
<blockquote>
<p>📌Eigen使用总结</p>
</blockquote>
<blockquote>
<p>📌<strong>值得做的习题，证明方面的。</strong></p>
<ol>
<li><p>验证旋转矩阵是正交矩阵。</p>
</li>
<li><p>&amp;#x20;一般线程方程 Ax &#x3D; b 有哪几种做法？你能在 Eigen 中实现吗？</p>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>视觉SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉SLAM十四讲-第二讲：初识SLAM</title>
    <url>/2022/08/26/%E8%A7%86%E8%A7%89SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2%E4%B9%8B%E7%AC%AC%E4%BA%8C%E8%AE%B2/</url>
    <content><![CDATA[<p>本文主要介绍视觉SLAM十四讲中第二讲的关键内容。</p>
<span id="more"></span>
<h2 id="第二讲：初识SLAM"><a href="#第二讲：初识SLAM" class="headerlink" title="第二讲：初识SLAM"></a>第二讲：初识SLAM</h2><p>一类传感器是<strong>携带于机器人本体上</strong>的，例如机器人的轮式编码器、相机、激光等等 ——通过间接测量数据推算位置，好处是对环境没有提出要求，适用于位置环境。</p>
<p>一类是<strong>安装于环境中</strong>的，例如前面讲的导轨、二维码标志等等。   —— 约束了外界环境，限制了使用范围</p>
<blockquote>
<p>📌</p>
<p><strong>单目相机</strong>是三维空间的二维投影，因此，如果想恢复三维结构，必须移动相机的视角。</p>
<p>因此，<strong>单目相机平移之后才能计算深度，并且无法确定真实尺度</strong>，问题的本质在于通过单张图像无法确定深度。</p>
</blockquote>
<blockquote>
<p>📌<strong>双目相机</strong>和<strong>深度相机</strong>，目的在于通过某种手段测量物体距离我们的距离，回复距离信息，因此场景的三维结构可以通过单张图线回复，也就消除了尺度不确定性。</p>
<p>双目相机测量到的深度范围与基线相关。基线距离越大，能够测量到的就越远</p>
<p><strong>双目或多目相机的缺点</strong>是配置与标定均较为复杂，其深度量程和精度受双目的基线与分辨率限制，而且视差的计算非常消耗计算资源</p>
<p><strong>深度相机</strong>（又称 RGB-D 相机)右开始兴起的一种相机，它最大的特点是可以通过红外结构光或 Time-of-Flight（ToF）原理，像激光传感器那样，通过主动向物体发射光并接收返回的光，测出物体离相机的距离。<strong>区别于双目相机是采用计算的方式获得深度，深度相机是通过物理方式，避免了大量的计算。</strong></p>
</blockquote>
<p>视觉里程计只计算相邻时刻的运动，而和再往前的过去的信息没有关联。仅通过视觉里程计估计轨迹，将不可避免的出现累积漂移。每次估计都会有一定的误差，由于里程计只估计相邻时刻的运动，先前时刻的误差将会传递到下一时刻，导致一段时间后估计的轨迹不再准确。</p>
<p>后端优化主要指处理 SLAM 过程中噪声的问题。后端优化要考虑的问题，就是如何从这些带有噪声的数据中，估计整个系统的状态，以及这个状态估计的不确定性有多大——这称为最大后验概率估（Maximum-a-Posteriori，MAP）。</p>
<p>为了实现回环检测，我们需要让机器人具有识别曾到达过的场景的能力。</p>
<blockquote>
<p>📌<strong>SLAM问题的数学表述</strong></p>
<p><img data-src="https://s2.loli.net/2022/08/26/HR8BbFdckGSAUpP.png" alt="SLAM运动和观测方程.png"></p>
<p>方程1是运动方程，方程2是观测方程</p>
<p>其中uk代表传感器输入，z代表传感器观测，y代表路标。</p>
<p>运动方程:  相机是六自由度姿态，两次位姿之间的关系相差一个旋转矩阵。</p>
<p>观测方程：z是在xk位置观测到yj所产生的观测数据。例如，在xk看到一个特征点，获得他的像素坐标[u,v]，由三维空间点获得像素坐标，这是<strong>相机模型。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>视觉SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>解决typora提示:This beta version of Typora is expired</title>
    <url>/2022/08/27/%E8%A7%A3%E5%86%B3typora%E6%8F%90%E7%A4%BAThis%20beta%20version%20of%20Typora%20is%20expired/</url>
    <content><![CDATA[<p>解决typora提示This beta version of Typora is expired, please download and install a newer version<br>自从typora付费之后也没有怎么使用，后来做git仓库+picgo+typora联动的时候，再次打开typora，弹出了以下窗口：</p>
<span id="more"></span>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208271020322.png" alt="ERROR提示"></p>
<p>我重新下载了付费版本的typora然后然后开启了15天尝鲜。但是我发现之后再想用typora打开md文档的时候依然会出现这个提示框，并且无论是点击确定还是×掉都依然会跳转到typora的安装界面。</p>
<p>这个错误提示大概的意思就是beta版本的typora已经过，需要下载最新版本。</p>
<p>在网上查找了一圈解决办法，目前通过修改注册表解决了我的问题。</p>
<p>以下是解决步骤：</p>
<p>1、win+r 打开运行窗口 &amp;#x20;<br>2、在搜索栏输入regedit，回车后打开注册表 &amp;#x20;<br>3、在注册表中找到：计算机\HKEY_CURRENT_USER\Software\Typora &amp;#x20;<br>4、鼠标右键Typora，选择权限 &amp;#x20;<br>5、选择Administraors，将下面的权限选择为拒绝</p>
<p>点击应用的时候可能会出现提醒，点确定就行了。最后保存设置。</p>
<p><img data-src="https://raw.githubusercontent.com/NatureLan-sudo/tuchuang/main/img/202208271021324.png" alt="修改typora权限"></p>
<p>6、重新打开typora，就可以正常应用了。</p>
<p>以上就是问题的解决方法。</p>
]]></content>
      <categories>
        <category>一些奇奇怪怪的问题之windows</category>
      </categories>
      <tags>
        <tag>typora</tag>
      </tags>
  </entry>
</search>
